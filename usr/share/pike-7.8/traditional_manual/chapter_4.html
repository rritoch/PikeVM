<html><head><title>Reference Manual for Pike v7.8 release 116</title></head>
<body bgcolor='white' text='black'>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4. Operators</font></td></tr></table><br />
</dt><dd><p>To make it easier to write Pike, and to make the code somewhat shorter,
some functions can be called with just one or two characters in the code.
These functions are called <b>operators</b> and we have already seen how
they work in plenty of examples. In this chapter I will describe in detail
what they do. The operators are divided into categories depending on their
function, but beware that some operators have meanings that go way beyond
the scope of the category they are in.</p></dd>
<dt><a name='1'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.1. Arithmetic operators</font></td></tr></table><br />
</dt>
<dd><p>The arithmetic operators are the simplest ones, since they work just like
you remember from math in school. The arithmetic operators are:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Identifier</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>Addition</td><td bgcolor='white'><font face='courier'><code>a&nbsp;+&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`+</code></font></td><td bgcolor='white'>the sum of a and b</td></tr>
<tr valign='top'><td bgcolor='white'>Subtraction</td><td bgcolor='white'><font face='courier'><code>a&nbsp;-&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`-</code></font></td><td bgcolor='white'>b subtracted from a</td></tr>
<tr valign='top'><td bgcolor='white'>Negation</td><td bgcolor='white'><font face='courier'><code>-&nbsp;a</code></font></td><td bgcolor='white'><font face='courier'><code>`-</code></font></td><td bgcolor='white'>minus a</td></tr>
<tr valign='top'><td bgcolor='white'>Multiplication</td><td bgcolor='white'><font face='courier'><code>a&nbsp;*&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`*</code></font></td><td bgcolor='white'>a multiplied by b</td></tr>
<tr valign='top'><td bgcolor='white'>Division</td><td bgcolor='white'><font face='courier'><code>a&nbsp;/&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`/</code></font></td><td bgcolor='white'>a divided by b</td></tr>
<tr valign='top'><td bgcolor='white'>Modulo</td><td bgcolor='white'><font face='courier'><code>a&nbsp;%&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`%</code></font></td><td bgcolor='white'>the remainder of a division between a and b</td></tr>
</table></td></tr></table><br />
<p>The third column, "Identifier" is the name of the function that actually
evaluates the operation. For instance, <font face='courier'><code>a&nbsp;+&nbsp;b</code></font> can also be written
as <font face='courier'><code>`+(a,&nbsp;b)</code></font>. I will show you how useful this can be at the end
of this chapter.</p><p>When applied to integers or floats these operators do exactly what they
are supposed to do. The only operator in the list not known from basic
math is the <b>modulo</b> operator. The modulo operator returns the
remainder from an integer division. It is the same as calculating
<font face='courier'><code>a&nbsp;-&nbsp;floor(a&nbsp;/&nbsp;b)&nbsp;*&nbsp;b</code></font>. <font face='courier'><code>floor</code></font> rounds the value down to
closest lower integer value. Note that the call to <font face='courier'><code>floor</code></font> isn't
needed when operating on integers, since dividing two integers will return
the result as an integer and it is always rounded down. For instance,
<font face='courier'><code>8&nbsp;/&nbsp;3</code></font> would return <font face='courier'><code>2</code></font>.</p><p>If all arguments to the operator are integers, the
result will also be an integer. If one is a float and the other is
an integer, the result will be a float. If both arguments are float,
the result will of course be a float.</p><p>However, there are more types in Pike than integers and floats. Here is
the complete list of combinations of types you can use with these operators:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Operation</b></td><td bgcolor='white'><b>Returned type</b></td><td bgcolor='white'><b>Returned value</b></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>int + int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>the sum of the two values</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>float + int
int + float
float + float</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>the sum of the two values</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string + string
int + string
float + string
string + int
string + float</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>In this case, any int or float is first converted to a string. Then
  the two strings are concatenated and the resulting string is returned.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array + array</code></pre></font></td><td bgcolor='white'>array</td><td bgcolor='white'>The two arrays are concatenated into a new array and that new
   array is returned.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>mapping + mapping</code></pre></font></td><td bgcolor='white'>mapping</td><td bgcolor='white'>A mapping with all the index-value pairs from both mappings is
   returned. If an index is present in both mappings the index-value pair
   from the right mapping will be used.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>multiset + multiset</code></pre></font></td><td bgcolor='white'>multiset</td><td bgcolor='white'>A multiset with all the indices from both multisets is returned.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>int - int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>The right value subtracted from the left.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>float - int
int - float
float - float</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>The right value subtracted from the left.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string - string</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>A copy of the left string with all occurrences of the right string
   removed.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array - array</code></pre></font></td><td bgcolor='white'>array</td><td bgcolor='white'>A copy of the left array with all elements present in the right array
   removed. Example: <font face='courier'><code>({2,1,4,5,3,6,7})&nbsp;-&nbsp;({3,5,1})</code></font> will return
   <font face='courier'><code>({2,4,6,7})</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>mapping - mapping</code></pre></font></td><td bgcolor='white'>mapping</td><td bgcolor='white'>A new mapping with all index-value pairs from the left mapping, except
   those indices that are also present in the right mapping.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>multiset - multiset</code></pre></font></td><td bgcolor='white'>multiset</td><td bgcolor='white'>A copy of the left multiset without any index present in the left
   multiset.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>- int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>Same as <font face='courier'><code>0&nbsp;-&nbsp;int</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>- float</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>Same as <font face='courier'><code>0&nbsp;-&nbsp;float</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>int * int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>the product of the two values</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>float * int
int * float
float * float</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>the product of the two values</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array(string) * string</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>All the strings in the array are concatenated with the string on the
   right in between each string. Example: <font face='courier'><code>({"foo","bar"})*"-"</code></font>
   will return <font face='courier'><code>"foo-bar"</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array(array) * array</code></pre></font></td><td bgcolor='white'>array</td><td bgcolor='white'>All the arrays in the left array are concatenated with the array on
   the right in between each array. Example: <font face='courier'><code>({&nbsp;({"foo"})&nbsp;,({"bar"})})*({"-"})</code></font>
   will return <font face='courier'><code>({&nbsp;"foo","-","bar"&nbsp;})</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string * int</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>This operation will concatenate the string N times. Example:
   <font face='courier'><code>"foo"*3</code></font> will return <font face='courier'><code>"foofoofoo"</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string * float</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>This operation will concatenate the string X times. Example:
   <font face='courier'><code>"foo"*2.5</code></font> will return <font face='courier'><code>"foofoofo"</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array * int</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>This operation will concatenate the array N times. Example:
   <font face='courier'><code>({"foo"})*3</code></font> will return <font face='courier'><code>({"foo","foo","foo"})</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array * float</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>This operation will concatenate the array X times. Example:
   <font face='courier'><code>({1,2,3})*2.5</code></font> will return <font face='courier'><code>({1,2,3,1,2,3,1,2})</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>int / int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>The right integer divided by the left integer rounded towards
   minus infinity.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>float / int
int / float
float / float</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>The right value divided by the left value.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string / string</code></pre></font></td><td bgcolor='white'>array(string)</td><td bgcolor='white'>In symmetry with the multiplication operator, the division operator
   can split a string into pieces. The right string will be split at every
   occurrence of the right string and an array containing the results will
   be returned. Example: <font face='courier'><code>"foo-bar"/"-"</code></font> will return
   <font face='courier'><code>({"foo","bar"})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string / int</code></pre></font></td><td bgcolor='white'>array(string)</td><td bgcolor='white'>This will split the string into pieces. The size of the pieces is
   given by the integer. Only complete pieces will be included in the result,
   the 'reminder' is discarded. Example: <font face='courier'><code>"foo-bar"/2</code></font> will
   return <font face='courier'><code>({"fo","o-","ba"})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string / float</code></pre></font></td><td bgcolor='white'>array(string)</td><td bgcolor='white'>This is similar to dividing a string with an integer, but it allows
   fraction-sized segments and the reminder will always be included.
   Example: <font face='courier'><code>"foo-bar"/2.5</code></font> will return
   <font face='courier'><code>({"fo","o-b","ar"})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array / int</code></pre></font></td><td bgcolor='white'>array(array)</td><td bgcolor='white'>This is similar to dividing a string with an integer, but splits an
   array. Example: <font face='courier'><code>({1,2,3,4,5,6,7})/2</code></font> will return
   <font face='courier'><code>({({1,2}),({3,4}),({5,6})})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array / float</code></pre></font></td><td bgcolor='white'>array(array)</td><td bgcolor='white'>You should be able to predict what this does by now. :) Example:
   <font face='courier'><code>({1,2,3,4,5,6,7,8})/2.5</code></font> will return
   <font face='courier'><code>({({1,2}),({3,4,5}),({6,7}),({8})})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>int % int</code></pre></font></td><td bgcolor='white'>int</td><td bgcolor='white'>The remainder of a division. If <font face='courier'><code>a</code></font> and <font face='courier'><code>b</code></font>
   are integers, <font face='courier'><code>a%b</code></font> is the same as <font face='courier'><code>a-(a/b)*b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>float % float
int % float
float % int</code></pre></font></td><td bgcolor='white'>float</td><td bgcolor='white'>The remainder of a division. If <font face='courier'><code>a</code></font> and <font face='courier'><code>b</code></font>
   are floats, <font face='courier'><code>a%b</code></font> is the same as <font face='courier'><code>a-floor(a/b)*b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string % int</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>The remainder of a string division. Example: <font face='courier'><code>"foo-bar"%2</code></font>
   will return <font face='courier'><code>"r"</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array % int</code></pre></font></td><td bgcolor='white'>string</td><td bgcolor='white'>The remainder of an array division. Example: <font face='courier'><code>({1,2,3,4,5,6,7})%2</code></font>
   will return <font face='courier'><code>({7})</code></font></td></tr>
</table></td></tr></table><br />
</dd>
<dt><a name='2'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.2. Comparison operators</font></td></tr></table><br />
</dt>
<dd><p>The arithmetic operators would be hard to use for anything interesting
without the ability to compare the results to each other.
For this purpose there are six comparison operators:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Identifier</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>Same</td><td bgcolor='white'><font face='courier'><code>a&nbsp;==&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`==</code></font></td><td bgcolor='white'>1 if a is the same value as b, 0 otherwise</td></tr>
<tr valign='top'><td bgcolor='white'>Not same</td><td bgcolor='white'><font face='courier'><code>a&nbsp;!=&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`!=</code></font></td><td bgcolor='white'>0 if a is the same value as b, 1 otherwise</td></tr>
<tr valign='top'><td bgcolor='white'>Greater than</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&gt;&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&gt;&nbsp;</code></font></td><td bgcolor='white'>1 if a is greater than b, 0 otherwise</td></tr>
<tr valign='top'><td bgcolor='white'>Greater than or equal to</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&gt;=&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&gt;=</code></font></td><td bgcolor='white'>1 if a is greater to or equal to b, 0 otherwise</td></tr>
<tr valign='top'><td bgcolor='white'>Lesser than</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&lt;&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&lt;&nbsp;</code></font></td><td bgcolor='white'>1 if a is lesser than b, 0 otherwise</td></tr>
<tr valign='top'><td bgcolor='white'>Lesser than or equal to</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&lt;=&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&lt;=</code></font></td><td bgcolor='white'>1 if a is lesser than or equal to b, 0 otherwise</td></tr>
</table></td></tr></table><br />
<p>The <font face='courier'><code>==</code></font> and <font face='courier'><code>!=</code></font> operators can be used on any type. For two
values to be <b>same</b> they must be the same type. Therefore 1 and 1.0 are
not <b>same</b>. Also, for two values of <b>pointer types</b> to be the same
the two values must be pointers to the same object. It is not enough that
the two objects are of the same size and contain the same data.</p><p>The other operators in the table above can only be used with integers, floats
and strings. If you compare an integer with a float, the int will be promoted
to a float before the comparison. When comparing strings, lexical order is
used and the values of the environment variables <tt>LC_CTYPE</tt> and
<tt>LC_LANG</tt> are respected.</p></dd>
<dt><a name='3'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.3. Logical operators</font></td></tr></table><br />
</dt>
<dd><p>Logical operators are operators that operate with truth values. In Pike any value
except zero is considered <b>true</b>. Logical operators are a very basic part
of Pike. They can also decide which arguments to evaluate and which not to
evaluate. Because of this the logical operators do not have any identifiers and
can not be called as normal functions. There are four logical operators:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>And</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&amp;&amp;&nbsp;b</code></font></td><td bgcolor='white'>If a is false, a is returned and b is not evaluated. Otherwise, b is
   returned.</td></tr>
<tr valign='top'><td bgcolor='white'>Or</td><td bgcolor='white'><font face='courier'><code>a&nbsp;||&nbsp;b</code></font></td><td bgcolor='white'>If a is true, a is returned and b is not evaluated. Otherwise, b is
   returned.</td></tr>
<tr valign='top'><td bgcolor='white'>Not</td><td bgcolor='white'><font face='courier'><code>!&nbsp;a</code></font></td><td bgcolor='white'>Returns 0 if a is true, 1 otherwise.</td></tr>
<tr valign='top'><td bgcolor='white'>If-else</td><td bgcolor='white'><font face='courier'><code>a&nbsp;?&nbsp;b&nbsp;:&nbsp;c</code></font></td><td bgcolor='white'>If a is true, b is returned and c is not evaluated. Otherwise c is
   returned and b is not evaluated.</td></tr>
</table></td></tr></table><br />
</dd>
<dt><a name='4'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.4. Bitwise/set operators</font></td></tr></table><br />
</dt>
<dd><p>These operators are used to manipulate bits as members in sets.
They can also manipulate arrays, multisets and mappings as sets.</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Identifier</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>Shift left</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&lt;&lt;&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&lt;&lt;</code></font></td><td bgcolor='white'>Multiplies a by 2 b times.</td></tr>
<tr valign='top'><td bgcolor='white'>Shift right</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&gt;&gt;&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&gt;&gt;</code></font></td><td bgcolor='white'>Divides a by 2 b times.</td></tr>
<tr valign='top'><td bgcolor='white'>Inverse (not)</td><td bgcolor='white'><font face='courier'><code>~&nbsp;a</code></font></td><td bgcolor='white'><font face='courier'><code>`~</code></font></td><td bgcolor='white'>Returns -1-a.</td></tr>
<tr valign='top'><td bgcolor='white'>Intersection (and)</td><td bgcolor='white'><font face='courier'><code>a&nbsp;&amp;&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`&amp;</code></font></td><td bgcolor='white'>All elements present in both a and b.</td></tr>
<tr valign='top'><td bgcolor='white'>Union (or)</td><td bgcolor='white'><font face='courier'><code>a&nbsp;|&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`|</code></font></td><td bgcolor='white'>All elements present in a or b.</td></tr>
<tr valign='top'><td bgcolor='white'>Symmetric difference (xor)</td><td bgcolor='white'><font face='courier'><code>a&nbsp;^&nbsp;b</code></font></td><td bgcolor='white'><font face='courier'><code>`^</code></font></td><td bgcolor='white'>All elements present in a or b, but not present in both.</td></tr>
</table></td></tr></table><br />
<p>The first three operators can only be used with integers and should be
pretty obvious.</p><p>The other three, intersection, union and symmetric difference, can be used with
integers, arrays, multisets and mappings. When used with integers, these
operators considers each bit in the integer a separate element. If you do
not know about how bits in integers work I suggest you go look it up in some other
programming book or just don't use these operators on integers.</p><p>When intersection, union or symmetric difference is used on an array each element
in the array is considered by itself. So intersecting two arrays will result
in an array with all elements that are present in both arrays. Example:
<font face='courier'><code>({7,6,4,3,2,1})&nbsp;&amp;&nbsp;({1,&nbsp;23,&nbsp;5,&nbsp;4,&nbsp;7})</code></font> will return
<font face='courier'><code>({7,4,1})</code></font>. The order of the elements in the returned array will
always be taken from the left array. Elements in multisets are treated
the same as elements in arrays. When doing a set operation on a mapping
however, only the indices are considered. The values are just copied with
the indices. If a particular index is present in both the right and left
argument to a set operator, the one from the right side will be used.
Example: <font face='courier'><code>([1:2])&nbsp;|&nbsp;([1:3])</code></font> will return <font face='courier'><code>([1:3])</code></font>.</p></dd>
<dt><a name='5'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.5. Indexing</font></td></tr></table><br />
</dt>
<dd><p>The index and range operators are used to retrieve information from a
complex data type.</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Identifier</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>Index</td><td bgcolor='white'><font face='courier'><code>a&nbsp;[&nbsp;b&nbsp;]</code></font></td><td bgcolor='white'><font face='courier'><code>`[]</code></font></td><td bgcolor='white'>Returns the index b from a.</td></tr>
<tr valign='top'><td bgcolor='white'>Lookup</td><td bgcolor='white'><font face='courier'><code>a&nbsp;-&gt;<i>identifier</i></code></font></td><td bgcolor='white'><font face='courier'><code>`-&gt;</code></font></td><td bgcolor='white'>Looks up the identifier. Same as a["<i>identifier</i>"].</td></tr>
<tr valign='top'><td bgcolor='white'>Assign index</td><td bgcolor='white'><font face='courier'><code>a&nbsp;[&nbsp;b&nbsp;]&nbsp;=&nbsp;c</code></font></td><td bgcolor='white'><font face='courier'><code>`[]=;</code></font></td><td bgcolor='white'>Sets the index b in a to c.</td></tr>
<tr valign='top'><td bgcolor='white'>Assign index</td><td bgcolor='white'><font face='courier'><code>a&nbsp;-&gt;<i>identifier</i>&nbsp;=&nbsp;c</code></font></td><td bgcolor='white'><font face='courier'><code>`-&gt;=</code></font></td><td bgcolor='white'>Sets the index "<i>identifier</i>" in a to c.</td></tr>
<tr valign='top'><td bgcolor='white'>Range</td><td bgcolor='white'><font face='courier'><code>a&nbsp;[&nbsp;b&nbsp;..&nbsp;c&nbsp;]</code></font></td><td bgcolor='white'><font face='courier'><code>`[..]</code></font></td><td bgcolor='white'>Returns a slice of a starting at the index b and ending at c.</td></tr>
<tr valign='top'><td bgcolor='white'>Range</td><td bgcolor='white'><font face='courier'><code>a&nbsp;[&nbsp;..&nbsp;c&nbsp;]</code></font></td><td bgcolor='white'><font face='courier'><code>`[..]</code></font></td><td bgcolor='white'>Returns a slice of a starting at the beginning of a and ending at c.</td></tr>
<tr valign='top'><td bgcolor='white'>Range</td><td bgcolor='white'><font face='courier'><code>a&nbsp;[&nbsp;b&nbsp;..&nbsp;]</code></font></td><td bgcolor='white'><font face='courier'><code>`[..]</code></font></td><td bgcolor='white'>Returns a slice of a from the index b to the end of a.</td></tr>
</table></td></tr></table><br />
<p>The index operator can be written in two different ways. It can be
written as <font face='courier'><code>ob&nbsp;[&nbsp;<i>index</i>&nbsp;]</code></font> or
<font face='courier'><code>ob-&gt;<i>identifier</i></code></font>. However, the latter syntax is
equal to <font face='courier'><code>ob&nbsp;[&nbsp;"<i>identifier</i>"&nbsp;]</code></font>.</p><p>You can only
index strings, arrays, mapping, multisets and objects, and some of these
can only be indexed on certain things as shown in this list:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Operation</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string[int]</code></pre></font></td><td bgcolor='white'>Returns the ascii value of the Nth character in the string.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array[int]</code></pre></font></td><td bgcolor='white'>Return the element in the array corresponding to the integer.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array[int]=mixed</code></pre></font></td><td bgcolor='white'>Sets the element in the array to the mixed value.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>mapping[mixed]
mapping-&gt;identifier</code></pre></font></td><td bgcolor='white'>Returns the value associated with the index, 0 if it is not found.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>mapping[mixed]=mixed
mapping-&gt;identifier=mixed</code></pre></font></td><td bgcolor='white'>Associate the second mixed value with the first mixed value.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>multiset[mixed]
multiset-&gt;identifier</code></pre></font></td><td bgcolor='white'>Returns 1 if the index (the value between the brackets) is present
   in the multiset, 0 otherwise.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>multiset[mixed]=mixed
multiset-&gt;identifier=mixed</code></pre></font></td><td bgcolor='white'>If the mixed value is <b>true</b> the index is added to the
   multiset. Otherwise the index is removed from the multiset.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>object[string]
object-&gt;identifier</code></pre></font></td><td bgcolor='white'>Returns the value of the named identifier in the object.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>object[string]=mixed
object-&gt;identifier=mixed</code></pre></font></td><td bgcolor='white'>Set the given identifier in the object to the mixed value. Only
   works if the identifier references a variable in the object.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>program[string]
program-&gt;identifier</code></pre></font></td><td bgcolor='white'>Returns the value of the named constant identifier in the program.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>string[int..int]</code></pre></font></td><td bgcolor='white'>Returns a piece of the string.</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><pre><code>array[int..int]</code></pre></font></td><td bgcolor='white'>Returns a slice of the array.</td></tr>
</table></td></tr></table><br />
<p>When indexing an <font face='courier'><code>array</code></font> or <font face='courier'><code>string</code></font> it is sometimes convenient
to access index from the end instead of from the beginning. This function
can be performed by using a negative index. Thus <font face='courier'><code>&nbsp;arr[-i]&nbsp;</code></font> is the
same as <font face='courier'><code>arr[sizeof(arr)-i]</code></font>. Note however that this behavior does
not apply to the range operator. Instead the range operator clamps it's
arguments to a suitable range. This means that
<font face='courier'><code><i>a</i>[<i>b</i>..<i>c</i>]</code></font> will be treated as follows:</p><ul>
<li> If <i>b</i> is less than zero, the range will begin at the start
     of the array as if <i>b</i> had been zero.</li>
<li> If <i>b</i> is greater or equal to sizeof(<i>a</i>) an empty array/string
     will be returned.</li>
<li> If <i>c</i> is less than <i>b</i>, an empty array/string will be
     returned.</li>
<li> If <i>c</i> is greater or equal to sizeof(<i>a</i>) the range will
     continue to the end of the array/string.</li>
<li> No errors are generated in any of the above cases.</li>
</ul></dd>
<dt><a name='6'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.6. The assignment operators</font></td></tr></table><br />
</dt>
<dd><p>There is really only one assignment operator, but it can be combined with
lots of other operators to make the code shorter. An assignment looks
like this:

<font face='courier'><pre><code>
	variable = expression;
</code></pre></font>

The <i>variable</i> can be a local variable, a global variable or an index
in an array, object, multiset or mapping. This will of course set the
value stored in <i>variable</i> to <i>expression</i>. Note that the above
is also an expression which returns the value of the <i>expression</i>.
This can be used in some interesting ways:

<font face='courier'><pre><code>
	variable1 = variable2 = 1; // Assign 1 to both variables
	variable1 =(variable2 = 1); // Same as above

	// Write the value of the expression, if any
	if(variable = expression)
	  write(variable);
</code></pre></font>

Using assignments like this can however be confusing to novice users, or users
who come from a Pascal or Basic background. Especially the if statement
can be mistaken for <tt>if(<i>variable</i> == <i>expression</i>)</tt> which
would mean something completely different. As I mentioned earlier, the
assignment operator can be combined with another operator to form operators
that modify the contents of a variable instead of just assigning it.
Here is a list of all the combinations:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Same as</b></td><td bgcolor='white'><b>Function</b></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;+=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> + <i>expression</i></td><td bgcolor='white'>Add <i>expression</i> to <i>variable</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;-=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> - <i>expression</i></td><td bgcolor='white'>Subtract <i>expression</i> from <i>variable</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;*=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> * <i>expression</i></td><td bgcolor='white'>Multiply <i>variable</i> with <i>expression</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;/=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> / <i>expression</i></td><td bgcolor='white'>Divide <i>variable</i> by <i>expression</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;%=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> % <i>expression</i></td><td bgcolor='white'>Modulo <i>variable</i> by <i>expression</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;&lt;&lt;=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> &lt;&lt; <i>expression</i></td><td bgcolor='white'>Shift <i>variable</i><i>expression</i> bits left</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;&gt;&gt;=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> &gt;&gt; <i>expression</i></td><td bgcolor='white'>Shift <i>variable</i><i>expression</i> bits right</td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;|=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> | <i>expression</i></td><td bgcolor='white'>Or <i>variable</i> with <i>expression</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;&amp;=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> &amp; <i>expression</i></td><td bgcolor='white'>And <i>variable</i> with <i>expression</i></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code><i>variable</i>&nbsp;^=&nbsp;<i>expression</i></code></font></td><td bgcolor='white'><i>variable</i> = <i>variable</i> ^ <i>expression</i></td><td bgcolor='white'>Xor <i>variable</i> with <i>expression</i></td></tr>
</table></td></tr></table><br />
<p>In all of the above expressions <i>variable</i> can actually be any of type
of assignable values. Assignable values are also known as <b>lvalues</b> and
here is a list of <b>lvalues</b>:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Lvalue type</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Valid assignment type</b></td></tr>
<tr valign='top'><td bgcolor='white'> a local or global variable </td><td bgcolor='white'><i>identifier</i></td><td bgcolor='white'>same as variable</td></tr>
<tr valign='top'><td bgcolor='white'> an element in an array </td><td bgcolor='white'><i>array</i> [ <i>int</i> ]</td><td bgcolor='white'>any type</td></tr>
<tr valign='top'><td bgcolor='white'> elements in elements in an array </td><td bgcolor='white'><i>array</i> [ <i>string</i> ]</td><td bgcolor='white'>any type This is like map(arr, `[]=,string_indexing_element, assignment_element)</td></tr>
<tr valign='top'><td bgcolor='white'> an element in an string </td><td bgcolor='white'><i>string</i> [ <i>int</i> ]</td><td bgcolor='white'>integer</td></tr>
<tr valign='top'><td bgcolor='white'> an element in a mapping </td><td bgcolor='white'><i>mapping</i>[<i>mixed</i>] or <i>mapping</i>-&gt;<i>identifier</i></td><td bgcolor='white'>any type</td></tr>
<tr valign='top'><td bgcolor='white'> an element in a multiset </td><td bgcolor='white'><i>multiset</i>[<i>mixed</i>] or <i>multiset</i>-&gt;<i>identifier</i></td><td bgcolor='white'>true / false</td></tr>
<tr valign='top'><td bgcolor='white'> a variable in an object </td><td bgcolor='white'><i>object</i>[<i>string</i>] or <i>object</i>-&gt;<i>identifier</i></td><td bgcolor='white'>same type as named variable</td></tr>
<tr valign='top'><td bgcolor='white'> a list of lvalues  </td><td bgcolor='white'> [ <i>lvalue</i>, <i>lvalue</i> ] </td><td bgcolor='white'> an array, first value in the array will be assigned to the first lvalue in the list, second value in the array to the second value in the list etc. </td></tr>
</table></td></tr></table><br />
</dd>
<dt><a name='7'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.7. The rest of the operators</font></td></tr></table><br />
</dt>
<dd><p>Now there are only a couple of operators left. I have grouped them together
in this section, not because they are not important, but because they do
not fit in any particular categories.</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>Function</b></td><td bgcolor='white'><b>Syntax</b></td><td bgcolor='white'><b>Identifier</b></td><td bgcolor='white'><b>Returns</b></td></tr>
<tr valign='top'><td bgcolor='white'>Calling</td><td bgcolor='white'><tt>a ( <i>args</i> )</tt></td><td bgcolor='white'><tt>`()</tt></td><td bgcolor='white'>Calls the function a.</td></tr>
<tr valign='top'><td bgcolor='white'>splice</td><td bgcolor='white'><tt>@ <i>a</i></tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Sends each element in the array a as an individual argument to a function call.</td></tr>
<tr valign='top'><td bgcolor='white'>Increment</td><td bgcolor='white'><tt>++ a</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Increments a and returns the new value of a.</td></tr>
<tr valign='top'><td bgcolor='white'>Decrement</td><td bgcolor='white'><tt>-- a</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Decrements a and returns the new value of a.</td></tr>
<tr valign='top'><td bgcolor='white'>Post increment</td><td bgcolor='white'><tt>a ++</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Increments a and returns the old value of a.</td></tr>
<tr valign='top'><td bgcolor='white'>Post decrement</td><td bgcolor='white'><tt>a --</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Decrements a and returns the old value of a.</td></tr>
<tr valign='top'><td bgcolor='white'>casting</td><td bgcolor='white'><tt>(<i>type</i>) a</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Tries to convert a into a value of the specified type.</td></tr>
<tr valign='top'><td bgcolor='white'>Null</td><td bgcolor='white'><tt>a, b</tt></td><td bgcolor='white'>none</td><td bgcolor='white'>Evaluates a and b, then returns b.</td></tr>
</table></td></tr></table><br />
<p>The most important of these operators is the calling operator. It is used
to call functions. The operator itself is just a set of parenthesis placed
after the expression that returns the function. Any arguments to the function
should be placed between the parenthesis, separated by commas. We have
already seen many examples of this operator, although you might not have
realized it was an operator at the time. The function call operator can
do more than just calling functions though; if the 'function' is in fact
an array, the operator will loop over the array and call each element in
the array and returns an array with the results.</p><p>If on the other hand, the 'function' is a program, the operator will
clone an object from the program and call create() in the new object
with the arguments given. In fact, the function <tt>clone</tt> is
implemented like this:

<font face='courier'><pre><code>
object clone(mixed p, mixed ... args) { ( (program)p )(@args); }
</code></pre></font>

On the subject of function calls, the splice operator should also be mentioned.
The splice operator is an at sign in front of an expression. The expression
should always be an array. The splice operator sends each of the elements
in the array as a separate argument to the function call. The splice operator
can only be used in an argument list for a function call.</p><p>Then there are the increment and decrement operators. The increment and
decrement operators are somewhat limited: they can only be used on
integers. They provide a short and fast way to add or subtract one
to an integer. If the operator is written before the variable
(<tt>++<i>a</i></tt>) the returned value will be what the variable
is after the operator has added/subtracted one to it. If the operator
is after the variable (<tt><i>a</i>++</tt>) it will instead return the
value of the variable before it was incremented/decremented.</p><p>Casting is used to convert one type to another, not all casts are
possible. Here is a list of all casts that actually _do_ anything:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>casting from</b></td><td bgcolor='white'><b>to</b></td><td bgcolor='white'><b>operation</b></td></tr>
<tr valign='top'><td bgcolor='white'>int</td><td bgcolor='white'>string</td><td bgcolor='white'>Convert the int to ASCII representation</td></tr>
<tr valign='top'><td bgcolor='white'>float</td><td bgcolor='white'>string</td><td bgcolor='white'>Convert the float to ASCII representation</td></tr>
<tr valign='top'><td bgcolor='white'>string</td><td bgcolor='white'>int</td><td bgcolor='white'>Convert decimal, octal or hexadecimal number to an int. Note that this will only work with decimal numbers in future versions.</td></tr>
<tr valign='top'><td bgcolor='white'>string</td><td bgcolor='white'>float</td><td bgcolor='white'>Convert ASCII number to a float.</td></tr>
<tr valign='top'><td bgcolor='white'>string</td><td bgcolor='white'>program</td><td bgcolor='white'>String is a filename, compile the file and return the program. Results are cached.</td></tr>
<tr valign='top'><td bgcolor='white'>string</td><td bgcolor='white'>object</td><td bgcolor='white'>This first casts the string to a program, (see above) and then clones the result. Results are cached.</td></tr>
<tr valign='top'><td bgcolor='white'>object</td><td bgcolor='white'><i>type</i></td><td bgcolor='white'>This calls the function 'cast' with a string containing the type as an argument.</td></tr>
<tr valign='top'><td bgcolor='white'>string</td><td bgcolor='white'>array</td><td bgcolor='white'>Same as doing <font face='courier'><code>values(<i>string</i>)</code></font></td></tr>
<tr valign='top'><td bgcolor='white'>array(int)</td><td bgcolor='white'>string</td><td bgcolor='white'>This does the inverse of the operation above. Ie. it constructs a string from an array of integers.</td></tr>
<tr valign='top'><td bgcolor='white'>array</td><td bgcolor='white'>array(<i>type</i>)</td><td bgcolor='white'>This recursively casts all values in the array to <i>type</i>.</td></tr>
<tr valign='top'><td bgcolor='white'>mapping</td><td bgcolor='white'>array</td><td bgcolor='white'>Same as <font face='courier'><code>Array.transpose(({indices(<i>mapping</i>),values(<i>mapping</i>))</code></font>. Example: <font face='courier'><code>(array)([1:2,3:4])</code></font> will return <font face='courier'><code>({&nbsp;({1,2}),&nbsp;({3,4})&nbsp;})</code></font></td></tr>
<tr valign='top'><td bgcolor='white'>multiset</td><td bgcolor='white'>array</td><td bgcolor='white'>Same as doing <font face='courier'><code>indices(<i>multiset</i>)</code></font>.</td></tr>
<tr valign='top'><td bgcolor='white'>int</td><td bgcolor='white'>float</td><td bgcolor='white'>Returns a float with the same value as the integer.</td></tr>
<tr valign='top'><td bgcolor='white'>float</td><td bgcolor='white'>int</td><td bgcolor='white'>Returns the integer closest to the float.</td></tr>
<tr valign='top'><td bgcolor='white'>function</td><td bgcolor='white'>object</td><td bgcolor='white'>Same as <font face='courier'><code>function_object(<i>function</i>)</code></font>.</td></tr>
</table></td></tr></table><br />
<p>You can also use the cast operator to tell the compiler things.
If <tt>a</tt> is a variable of type mixed  containing an int, then the
expression <tt>(int)a</tt> can be used instead of <tt>a</tt> and that will
tell the compiler that the type of that expression is <tt>int</tt>.</p><p>Last, and in some respect least, is the comma operator. It doesn't do
much. In fact, it simply evaluates the two arguments and then returns
the right hand one. This operator is mostly useful to produce smaller code,
or to make defines that can be used in expressions.</p></dd>
<dt><a name='8'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.8. Operator precedence</font></td></tr></table><br />
</dt>
<dd><p>When evaluating an expression, you can always use parenthesis to tell
the compiler in which order to evaluate things. Normally, the compiler
will evaluate things from left to right, but it will evaluate operators
with higher priority before those with lower. The following table shows
the relative priority of all the operators in descending order:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>(a)&nbsp;a()&nbsp;a[b]&nbsp;a-&gt;b&nbsp;a[b..c]&nbsp;({})&nbsp;([])&nbsp;(&lt;&gt;)</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>!a&nbsp;~a&nbsp;(type)a&nbsp;++a&nbsp;--a</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a++&nbsp;a--</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a*b&nbsp;a/b&nbsp;a%b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a+b&nbsp;a-b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a&gt;&gt;b&nbsp;a&lt;&lt;b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a&gt;b&nbsp;a&gt;=b&nbsp;a&lt;b&nbsp;a&lt;=b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a==b&nbsp;a!=b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a&amp;b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a^b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a|b</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&amp;&amp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>||</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>a?b:c</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>=</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>@a</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>,</code></font></td></tr>
</table></td></tr></table><br />
<p>Examples:</p><table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><b>The expression</b></td><td bgcolor='white'><b>is evaluated in this order:</b></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;1+2*2&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;1+(2*2)&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;1+2*2*4&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;1+((2*2)*4)&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;(1+2)*2*4&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;((1+2)*2)*4&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;1+4,c=2|3+5&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;(1+4),(c=((2|3)+5))&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;1+5&nbsp;&amp;&nbsp;4&nbsp;==&nbsp;3&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;(1+(5&nbsp;&amp;&nbsp;4))&nbsp;==&nbsp;3&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;c=1,99&nbsp;</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;(c=1),99&nbsp;</code></font></td></tr>
<tr valign='top'><td bgcolor='white'><font face='courier'><code>&nbsp;!a++&nbsp;+&nbsp;~--a()</code></font></td><td bgcolor='white'><font face='courier'><code>&nbsp;(!(a++))&nbsp;+&nbsp;(~((--a)()))&nbsp;</code></font></td></tr>
</table></td></tr></table><br />
</dd>
<dt><a name='9'></a>
<table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 4.9. Operator functions</font></td></tr></table><br />
</dt>
<dd><p>As mentioned earlier <tt>a + b</tt> can just as well be written as
<tt>`+(a, b)</tt>. Together with the function <tt>map</tt> which
calls a function for every index in an array and the splice operator
this can be used to create some very very fast and compact code. Let's
look at some examples:</p><dl>
<dt><tt>map(arr, `-)</tt></dt>
<dd> This will return an array with each element negated.</dd>
<dt><tt>map(text/"\n",`/," ")</tt></dt>
<dd> This will divide a text into lines, each line will then be mapped
     through <tt>`/</tt> and divided into an array of words.</dd>
<dt><tt>`+(0, @arr)</tt></dt>
<dd> This will add all the integers in the array <tt>arr</tt> together.</dd>
<dt><tt>int abs(int a) { return ( a&gt;0 ? `+ : `-)(a); }</tt></dt>
<dd> This is a rather absurd but working function which will return the
     absolute value of a.</dd>
</dl></dd></dl></body></html>