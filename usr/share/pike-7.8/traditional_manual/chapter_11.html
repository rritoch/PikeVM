<html><head><title>Reference Manual for Pike v7.8 release 116</title></head>
<body bgcolor='white' text='black'>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; 11. Parsers</font></td></tr></table><br />
</dt><dd><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML</b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>autoconvert</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>autoconvert</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font><b>)</b></tt></p></dd>
</dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Validating</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Validating XML parser.</p>
<p> Validates an XML file according to a DTD.</p>
<p> cf http://wwww.w3.org/TR/REC-xml/</p>
<p> $Id: Validating.pike,v 1.20 2008/12/01 10:03:42 grubba Exp $</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Simple</b></font>
</font><dt>
<dd><p><font face='courier'>inherit .Simple</font><font face='courier'> : <font color='#F000F0'>Simple</font></font></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Extends the Simple XML parser.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isname</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isname</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid <tt>Name</tt>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnmtoken</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnmtoken</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid <tt>Nmtoken</tt>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnames</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnames</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid list of <tt>Name</tt>s.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnmtokens</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnmtokens</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid list of <tt>Nmtoken</tt>s.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_external_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_external_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>sysid</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>pubid</font>, <font color='#202020'>mapping</font>|<font color='#600000'>__deprecated__</font>(<font color='#202020'>int</font>)|<font color='#202020'>void</font> <font color='#005080'>info</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Get an external entity.</p>
<p> Called when a <tt>&lt;!DOCTYPE&gt;</tt> with a <tt>SYSTEM</tt> identifier
 is encountered, or when an entity reference needs expanding.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>sysid</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>SYSTEM</tt> identifier.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>pubid</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>PUBLIC</tt> identifier (if any).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>info</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The callbackinfo mapping containing the current parser state.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>extra</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>extra</tt> arguments as passed to <font face='courier'>parse()</font>  or <font face='courier'>parse_dtd()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a string with a DTD fragment on success.
   Returns <font face='courier'><code>0</code></font> (zero) on failure.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Returning zero will cause the validator to report an error.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>In Pike 7.7 and earlier <font face='courier'>info</font>  had the value <font face='courier'><code>0</code></font> (zero).</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The default implementation always returns <font face='courier'><code>0</code></font> (zero).
   Override this function to provide other behaviour.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse()</font> , <font face='courier'>parse_dtd()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>validate</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>validate</font>(</b><font color='#202020'>string</font> <font color='#005080'>kind</font>, <font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mapping</font> <font color='#005080'>attributes</font>, <font color='#202020'>array</font>|<font color='#202020'>string</font> <font color='#005080'>contents</font>, <font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>info</font>, <font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <font color='#005080'>extra</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The validation callback function.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>::parse()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>string</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>
<dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Document this function</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>string</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>
<dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Document this function</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Validating.Element</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML Element node.</p>
</font></dd></dl></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Simple</font></b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt><br />
<tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>dtd</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt><br />
<tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>dtd</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lookup_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>lookup_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the verbatim expansion of the entity.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Added in Pike 7.7.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>define_entity_raw</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>define_entity_raw</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>string</font> <font color='#005080'>raw</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Define an entity or an SMEG.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>entity</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Entity name, or SMEG name (if preceeded by a <font face='courier'><code>"%"</code></font>).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Verbatim expansion of the entity.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>define_entity()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>define_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>define_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Define an entity or an SMEG.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>entity</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Entity name, or SMEG name (if preceeded by a <font face='courier'><code>"%"</code></font>).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Expansion of the entity. Entity evaluation will be performed.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>define_entity_raw()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>allow_rxml_entities</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>allow_rxml_entities</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>yes_no</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>compat_allow_errors</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>compat_allow_errors</font>(</b><font color='#202020'>string</font> <font color='#005080'>version</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Set whether the parser should allow certain errors for
 compatibility with earlier versions. <font face='courier'>version</font>  can be:</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"7.2"</font></tt></td><td bgcolor='white'><p>Allow more data after the root element.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"7.6"</font></tt></td><td bgcolor='white'><p>Allow multiple and invalidly placed "&lt;?xml ... ?&gt;" and
     "&lt;!DOCTYPE ... &gt;" declarations (invalid "&lt;?xml ... ?&gt;"
     declarations are otherwise treated as normal PI:s). Allow
     "&lt;![CDATA[ ... ]]&gt;" outside the root element. Allow the root
     element to be absent.</p>
</td></tr>
</table></td></tr></table><br />
<p><font face='courier'>version</font>  can also be zero to enable all error checks.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Simple.Context</font></b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_xml</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_xml</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>parse_entity</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>push_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>push_string</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt><br />
<tt><font color='#202020'>void</font> <b><font color='#000066'>push_string</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>string</font> <font color='#005080'>context</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Add a string to parse at the current position.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>String to insert at the current parsing position.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>context</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Optional context used to refer to the inserted string.
   This is typically an URL, but may also be an entity
   (preceeded by an <font face='courier'><code>"&amp;"</code></font>) or a SMEG reference
   (preceeded by a <font face='courier'><code>"%"</code></font>).
   Not used by the XML parser as such, but is simply
   passed into the callbackinfo mapping as
   the field <font face='courier'><code>"context"</code></font> where it can be useful
   for eg resolving relative URLs when parsing DTDs,
   or for determining where errors occur.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.XML.Simple.Context<b>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>int</font> <font color='#005080'>flags</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt><br />
<tt><font color='#202020'>void</font> Parser.XML.Simple.Context<b>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>int</font> <font color='#005080'>flags</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>context</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>These two arguments are passed along to <font face='courier'>push_string()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>flags</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Parser flags.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>cb</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Callback function. This function gets called at various
   stages during the parsing.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.NSTree</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A namespace aware version of Parser.XML.Tree. This implementation
 does as little validation as possible, so e.g. you can call your
 namespace xmlfoo without complaints.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Tree</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Parser.XML.Tree</font><font face='courier'> : <font color='#F000F0'>Tree</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>NSNode</font> <b><font color='#000066'>parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>default_ns</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes a XML string <font face='courier'>data</font>  and produces a namespace node tree.
 If <font face='courier'>default_ns</font>  is given, it will be used as the default namespace.</p>
</font></dd>
<dt><font face='Helvetica'>Throws</font><dt>
<dd><font face='Helvetica'><p>Throws an <font face='courier'>error</font>  when an error is encountered during XML
   parsing.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>visualize</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>visualize</font>(</b><font color='#005080'>Node</font> <font color='#005080'>n</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>indent</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Makes a visualization of a node graph suitable for
 printing out on a terminal.</p>
</font></dd>
<dt><font face='Helvetica'>Example</font><dt>
<dd><pre><p>&gt; object x = parse_input("&lt;a&gt;&lt;b&gt;&lt;c/&gt;d&lt;/b&gt;&lt;b&gt;&lt;e/&gt;&lt;f&gt;g&lt;/f&gt;&lt;/b&gt;&lt;/a&gt;");
   &gt; write(visualize(x));
   Node(ROOT)
     NSNode(ELEMENT,"a")
       NSNode(ELEMENT,"b")
         NSNode(ELEMENT,"c")
         NSNode(TEXT)
       NSNode(ELEMENT,"b")
         NSNode(ELEMENT,"e")
         NSNode(ELEMENT,"f")
           NSNode(TEXT)
   Result 1: 201</p>
</pre></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.NSTree.NSNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Namespace aware node.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Node</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Node</font><font face='courier'> : <font color='#F000F0'>Node</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_ns</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the namespace in which the current element is defined in.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_default_ns</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_default_ns</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the default namespace in the current scope.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_defined_nss</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_defined_nss</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a mapping with all the namespaces defined in the current
 scope, except the default namespace.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned mapping is the same as the one in the node, so
   destructive changes will affect the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_ns_attributes</font>(</b><font color='#202020'>string</font> <font color='#005080'>namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the attributes in this node that is declared in the provided
 namespace.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)) <b><font color='#000066'>get_ns_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the attributes in all namespaces that is associated with
 this node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned mapping is the same as the one in the node, so
   destructive changes will affect the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_namespace</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>add_namespace</font>(</b><font color='#202020'>string</font> <font color='#005080'>ns</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>symbol</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>chain</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds a new namespace to this node. The preferred symbol to
 use to identify the namespace can be provided in the <font face='courier'>symbol</font> 
 argument. If <font face='courier'>chain</font>  is set, no attempts to overwrite an
 already defined namespace with the same identifier will be made.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>diff_namespaces</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>diff_namespaces</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the difference between this nodes and its parents namespaces.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_xml_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_xml_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the element name as it occurs in xml files. E.g.
 "zonk:name" for the element "name" defined in a namespace
 denoted with "zonk". It will look up a symbol for the namespace
 in the symbol tables for the node and its parents. If none is
 found a new label will be generated by hashing the namespace.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>NSNode</font> <font color='#005080'>child</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The remove_child is a not updated to take care of name
 space issues. To properly remove all the parents name spaces
 from the chid, call <font face='courier'>remove_node</font>  in the child.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.Tree</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML parser that generates node-trees.</p>
<p> Has some support for XML namespaces
 <a href='http://www.w3.org/TR/REC-xml-names/'>http://www.w3.org/TR/REC-xml-names/</a>
 RFC 2518 23.4.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>This module defines two sets of node trees;
   the <font face='courier'>SimpleNode</font> -based, and the <font face='courier'>Node</font> -based.
   The main difference between the two, is that
   the <font face='courier'>Node</font> -based trees have parent pointers,
   which tend to generate circular data references
   and thus garbage.</p>
<p>   There are some more subtle differences between
   the two. Please read the documentation carefully.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>STOP_WALK</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>STOP_WALK</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ROOT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ROOT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ELEMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ELEMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_TEXT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_TEXT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_HEADER</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_HEADER</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_PI</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_PI</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_COMMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_COMMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_DOCTYPE</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_DOCTYPE</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ATTR</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ATTR</font></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Attribute nodes are created on demand</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ENTITY</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ENTITY</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ELEMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ELEMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ATTLIST</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ATTLIST</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_NOTATION</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_NOTATION</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_NODE</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_NODE</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>text_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>text_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes the string given in <font face='courier'>data</font>  by escaping &amp;, &lt; and &gt;.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>roxen_text_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>roxen_text_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes strings just like <font face='courier'>text_quote</font> , but entities in the form
 <tt>&amp;foo.bar;</tt> will not be quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>attribute_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>attribute_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes the string given in <font face='courier'>data</font>  by escaping &amp;, &lt;, &gt;, ' and ".</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>roxen_attribute_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>roxen_attribute_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes strings just like <font face='courier'>attribute_quote</font> , but entities in the
 form <tt>&amp;foo.bar;</tt> will not be quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleRootNode</font> <b><font color='#000066'>simple_parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>predefined_entities</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>default_namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes an XML string and produces a <font face='courier'>SimpleNode</font>  tree.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_parse_file</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleRootNode</font> <b><font color='#000066'>simple_parse_file</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>predefined_entities</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>default_namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Loads the XML file <font face='courier'>path</font> , creates a <font face='courier'>SimpleNode</font>  tree representation and
 returns the root node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>RootNode</font> <b><font color='#000066'>parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>no_fallback</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>force_lowercase</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>predefined_entities</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>parse_namespaces</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes an XML string and produces a node tree.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flags</font>  is not used for <font face='courier'>PARSE_WANT_ERROR_CONTEXT</font> ,
 <font face='courier'>PARSE_FORCE_LOWERCASE</font>  or <font face='courier'>PARSE_ENABLE_NAMESPACES</font>  since they
 are covered by the separate flag arguments.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_file</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Node</font> <b><font color='#000066'>parse_file</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>parse_namespaces</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Loads the XML file <font face='courier'>path</font> , creates a node tree representation and
 returns the root node.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; ENUM <b><font color='#005080'>Parser.XML.Tree.ParseFlags</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Flags used together with <font face='courier'>simple_parse_input()</font>  and
 <font face='courier'>simple_parse_file()</font> .</p>
</font></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.XMLNSParser</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Namespace aware parser.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>Enter</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>Enter</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>attrs</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check <font face='courier'>attrs</font>  for namespaces.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the namespace expanded version of <font face='courier'>attrs</font> .</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.AbstractSimpleNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Base class for nodes.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <b><font color='#000066'>get_children</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the nodes children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>count_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>count_children</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the number of children of the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>low_clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>low_clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns an initialized copy of the node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned node has no children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a clone of the sub-tree rooted in the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_last_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>get_last_child</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the last child node or zero.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`[]</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>`[]</font>(</b><font color='#202020'>int</font> <font color='#005080'>pos</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The [] operator indexes among the node children, so
 <font face='courier'><code>node[0]</code></font> returns the first node and <font face='courier'><code>node[-1]</code></font> the last.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The [] operator will select a node from all the nodes children,
   not just its element children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the given node to the list of children of this node. The
 new node is added last in the list.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The return value differs from the one returned
   by <font face='courier'>Node()-&gt;add_child()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_before</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_before</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added last if <font face='courier'>old</font>  is
 zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_after</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_after</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all occurrences of the provided node from the list of
 children of this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>replace_children</font>(</b><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <font color='#005080'>children</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the nodes children with the provided ones.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>replace_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the first occurrence of the old node child with
 the new node child.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The return value differs from the one returned
   by <font face='courier'>Node()-&gt;replace_child()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the current node on success, and <font face='courier'><code>0</code></font> (zero)
   if the node <font face='courier'>old</font>  wasn't found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>zap_tree</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>zap_tree</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Destruct the tree recursively. When the inheriting
 <font face='courier'>AbstractNode</font>  or <font face='courier'>Node</font>  is used, which have parent pointers,
 this function should be called for every tree that no longer is
 in use to avoid frequent garbage collector runs.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_preorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_preorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in preorder, root node first, then
 subtrees from left to right, calling the callback function
 for every node. If the callback function returns <font face='courier'>STOP_WALK</font> 
 the traverse is promptly aborted and <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_preorder_2</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_preorder_2</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>cb_1</font>, <font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>cb_2</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in preorder, root node first, then
 subtrees from left to right. For each node we call <font face='courier'>cb_1</font> 
 before iterating through children, and then <font face='courier'>cb_2</font> 
 (which always gets called even if the walk is aborted earlier).
 If the callback function returns <font face='courier'>STOP_WALK</font>  the traverse
 decend is aborted and <font face='courier'>STOP_WALK</font>  is returned once all waiting
 <font face='courier'>cb_2</font>  functions have been called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_inorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_inorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in inorder, left subtree first, then
 root node, and finally the remaining subtrees, calling the function
 <font face='courier'>callback</font>  for every node. If the function <font face='courier'>callback</font>  returns
 <font face='courier'>STOP_WALK</font>  the traverse is promptly aborted and <font face='courier'>STOP_WALK</font> 
 is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_postorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_postorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in postorder, first subtrees from left
 to right, then the root node, calling the function <font face='courier'>callback</font> 
 for every node. If the function <font face='courier'>callback</font>  returns <font face='courier'>STOP_WALK</font> 
 the traverse is promptly aborted and <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>iterate_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>iterate_children</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Iterates over the nodes children from left to right, calling the
 function <font face='courier'>callback</font>  for every node. If the callback function
 returns <font face='courier'>STOP_WALK</font>  the iteration is promptly aborted and
 <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendants</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <b><font color='#000066'>get_descendants</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>include_self</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a list of all descendants in document order. Includes
 this node if <font face='courier'>include_self</font>  is set.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.AbstractNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Base class for nodes with parent pointers.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractSimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractSimpleNode</font><font face='courier'> : <font color='#F000F0'>AbstractSimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_parent</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_parent</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>parent</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the parent node to <font face='courier'>parent</font> .</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_parent</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_parent</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the parent node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>low_clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>low_clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns an initialized copy of the node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned node has no children, and no parent.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>clone</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font>(-1..1) <font color='#005080'>direction</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clones the node, optionally connected to parts of the tree.
 If direction is -1 the cloned nodes parent will be set, if
 direction is 1 the clone nodes childen will be set.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_root</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_root</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Follows all parent pointers and returns the root node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>add_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Returns the new child node, NOT the current node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The new child node is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_before</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_before</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added last if <font face='courier'>old</font>  is
 zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_after</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_after</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child_before</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child_after</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt><br />
<tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child_before</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>old</font><b>)</b></tt><br />
<tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child_after</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Variants of <font face='courier'>add_child</font> , <font face='courier'>add_child_before</font>  and
 <font face='courier'>add_child_after</font>  that doesn't set the parent pointer in the
 newly added children.</p>
<p> This is useful while building a node tree, to get efficient
 refcount garbage collection if the build stops abruptly.
 <font face='courier'>fix_tree</font>  has to be called on the root node when the building
 is done.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>fix_tree</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>fix_tree</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Fix all parent pointers recursively in a tree that has been
 built with <font face='courier'>tmp_add_child</font> .</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all occurrences of the provided node from the called nodes
 list of children. The removed nodes parent reference is set to null.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_node</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_node</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes this node from its parent. The parent reference is set to null.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>replace_children</font>(</b><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <font color='#005080'>children</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the nodes children with the provided ones. All parent
 references are updated.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>replace_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>old</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the first occurrence of the old node child with
 the new node child. All parent references are updated.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned value is NOT the current node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new child node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_node</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>replace_node</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces this node with the provided one.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_preceding_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_preceding_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all preceding siblings, i.e. all siblings present before
 this node in the parents children list.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_following_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_following_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all following siblings, i.e. all siblings present after
 this node in the parents children list.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all siblings, including this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ancestors</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_ancestors</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>include_self</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a list of all ancestors, with the top node last.
 The list will start with this node if <font face='courier'>include_self</font>  is set.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_preceding</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_preceding</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all preceding nodes, excluding this nodes ancestors.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_following</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_following</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the nodes that follows after the current one.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.VirtualNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Node in XML tree</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns this nodes attributes, which can be altered
 destructivly to alter the nodes attributes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_short_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>get_short_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns this nodes name-space adjusted attributes.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>set_short_namespaces()</font>  must have been called before
   calling this function.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_node_type</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_node_type</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the node type. See defined node type constants.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_text</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_text</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns text content in node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_doc_order</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_doc_order</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_doc_order</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_doc_order</font>(</b><font color='#202020'>int</font> <font color='#005080'>o</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the element node, or the nearest element above if
 an attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_any_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_any_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return name of tag or name of attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_tag_name</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Change the tag name destructively. Can only be used on element and
 processing-instruction nodes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_namespace</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_namespace</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return the (resolved) namespace for this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_full_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_full_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return fully qualified name of the element node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.XML.Tree.VirtualNode<b>(</b><font color='#202020'>int</font> <font color='#005080'>type</font>, <font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mapping</font> <font color='#005080'>attr</font>, <font color='#202020'>string</font> <font color='#005080'>text</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>value_of_node</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>value_of_node</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If the node is an attribute node or a text node, its value is returned.
 Otherwise the child text nodes are concatenated and returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_first_element</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_first_element</font>(</b><font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>name</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>full</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the first element child to this node.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>name</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If provided, the first element child with that name is returned.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>full</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If specified, name matching will be done against the full name.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the first matching node, and 0 if no such node was found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>name</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>full</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all element children to this node.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>name</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If provided, only elements with that name is returned.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>full</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If specified, name matching will be done against the full name.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns an array with matching nodes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>cast</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>cast</font>(</b><font color='#202020'>string</font> <font color='#005080'>to</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>It is possible to cast a node to a string, which will return
 <font face='courier'>render_xml()</font>  for that node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>render_xml</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>render_xml</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>preserve_roxen_entities</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>namespace_lookup</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates an XML representation of the node sub tree. If the
 flag <font face='courier'>preserve_roxen_entities</font>  is set, entities on the form
 <tt>&amp;foo.bar;</tt> will not be escaped.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>namespace_lookup</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Mapping from namespace prefix to namespace symbol prefix.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>render_to_file</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>render_to_file</font>(</b><font color='#005080'>Stdio.File</font> <font color='#005080'>f</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>preserve_roxen_entities</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates an XML representation fo the node sub tree and streams
 the output to the file <font face='courier'>f</font> . If the flag <font face='courier'>preserve_roxen_entities</font> 
 is set, entities on the form <tt>&amp;foo.bar;</tt> will not be escaped.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.SimpleNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML node without parent pointers and attribute nodes.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractSimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractSimpleNode</font><font face='courier'> : <font color='#F000F0'>AbstractSimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>VirtualNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit VirtualNode</font><font face='courier'> : <font color='#F000F0'>VirtualNode</font></font></p></dd>
</dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.Node</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML node with parent pointers.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractNode</font><font face='courier'> : <font color='#F000F0'>AbstractNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>VirtualNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit VirtualNode</font><font face='courier'> : <font color='#F000F0'>VirtualNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the element node, or the nearest element above if
 an attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attr_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_attr_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attribute_nodes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Node</font>) <b><font color='#000066'>get_attribute_nodes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates and returns an array of new nodes; they will not be
 added as proper children to the parent node, but the parent
 link in the nodes are set so that upwards traversal is made
 possible.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.XMLParser</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Mixin for parsing XML.</p>
</font></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.SimpleRootNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The root node of an XML-tree consisting of <font face='courier'>SimpleNode</font> s.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>SimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit SimpleNode</font><font face='courier'> : <font color='#F000F0'>SimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>XMLParser</b></font>
</font><dt>
<dd><p><font face='courier'>inherit XMLParser</font><font face='courier'> : <font color='#F000F0'>XMLParser</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_element_by_id</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleElementNode</font> <b><font color='#000066'>get_element_by_id</font>(</b><font color='#202020'>string</font> <font color='#005080'>id</font>, <font color='#202020'>int</font>|<font color='#202020'>void</font> <font color='#005080'>force</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Find the element with the specified id.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>id</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The XML id of the node to search for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>force</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Force a regeneration of the id lookup cache.
   Needed the first time after the node tree has been
   modified by adding or removing element nodes, or
   by changing the id attribute of an element node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the element node with the specified id
   if any. Returns <font face='courier'>UNDEFINED</font>  otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flush_node_id_cache</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>flush_node_id_cache</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>flush_node_id_cache</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clears the node id cache built and used by <font face='courier'>get_element_by_id</font> .</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.RootNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The root node of an XML-tree consisting of <font face='courier'>Node</font> s.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Node</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Node</font><font face='courier'> : <font color='#F000F0'>Node</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>XMLParser</b></font>
</font><dt>
<dd><p><font face='courier'>inherit XMLParser</font><font face='courier'> : <font color='#F000F0'>XMLParser</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_element_by_id</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>ElementNode</font> <b><font color='#000066'>get_element_by_id</font>(</b><font color='#202020'>string</font> <font color='#005080'>id</font>, <font color='#202020'>int</font>|<font color='#202020'>void</font> <font color='#005080'>force</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Find the element with the specified id.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>id</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The XML id of the node to search for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>force</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Force a regeneration of the id lookup cache.
   Needed the first time after the node tree has been
   modified by adding or removing element nodes, or
   by changing the id attribute of an element node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the element node with the specified id
   if any. Returns <font face='courier'>UNDEFINED</font>  otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flush_node_id_cache</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>flush_node_id_cache</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>flush_node_id_cache</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clears the node id cache built and used by <font face='courier'>get_element_by_id</font> .</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.SloppyDOM</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A somewhat DOM-like library that implements lazy generation of the
 node tree, i.e. it's generated from the data upon lookup. There's
 also a little bit of XPath evaluation to do queries on the node
 tree.</p>
<p> Implementation note: This is generally more pragmatic than
 <font face='courier'>Parser.XML.DOM</font> , meaning it's not so pretty and compliant, but
 more efficient.</p>
<p> Implementation status: There's only enough implemented to parse a
 node tree from source and access it, i.e. modification functions
 aren't implemented. Data hiding stuff like NodeList and
 NamedNodeMap is not implemented, partly since it's cumbersome to
 meet the "live" requirement. Also, <font face='courier'>Parser.HTML</font>  is used in XML
 mode to parse the input. Thus it's too error tolerant to be XML
 compliant, and it currently doesn't handle DTD elements, like
 <tt>"&lt;!DOCTYPE"</tt>, or the XML declaration (i.e. <tt>"&lt;?xml
 version='1.0'?&gt;"</tt>.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Document</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>source</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>raw_values</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Normally entities are decoded, and <font face='courier'>Node.xml_format</font>  will encode
 them again. If <font face='courier'>raw_values</font>  is nonzero then all text and attribute
 values are instead kept in their original form.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.Node</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Basic node.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_text_content</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_text_content</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If the <tt>raw_values</tt> flag is set in the owning document, the
 text is returned with entities and CDATA blocks intact.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_path</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)|<font color='#005080'>Node</font>|<font color='#202020'>array</font>(<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)|<font color='#005080'>Node</font>)|<font color='#202020'>string</font> <b><font color='#000066'>simple_path</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>xml_format</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Access a node or a set of nodes through an expression that is a
 subset of an XPath RelativeLocationPath in abbreviated form.</p>
<p> That means one or more Steps separated by "/" or "//". A Step
 consists of an AxisSpecifier followed by a NodeTest and then
 optionally by one or more Predicate's.</p>
<p> "/" before a Step causes it to be matched only against the
 immediate children of the node(s) selected by the previous Step.
 "//" before a Step causes it to be matched against any children
 in the tree below the node(s) selected by the previous Step.
 The initial selection before the first Step is this element.</p>
<p> The currently allowed AxisSpecifier NodeTest combinations are:</p>
<ul>
<li><p><tt>name</tt> to select all elements with the given name. The
   name can be <tt>"*"</tt> to select all.</p>
</li><li><p><tt>@name</tt> to select all attributes with the given name. The
   name can be <tt>"*"</tt> to select all.</p>
</li><li><p><tt>comment()</tt> to select all comments.</p>
</li><li><p><tt>text()</tt> to select all text and CDATA blocks. Note that
   all entity references are also selected, under the assumption
   that they would expand to text only.</p>
</li><li><p><tt>processing-instruction("name")</tt> to select all processing
   instructions with the given name. The name can be left out to
   select all. Either <tt>'</tt> or <tt>"</tt> may be used to delimit
   the name. For compatibility, it can also occur without
   surrounding quotes.</p>
</li><li><p><tt>node()</tt> to select all nodes, i.e. the whole content of an
   element node.</p>
</li><li><p><tt>.</tt> to select the currently selected element itself.</p>
</li></ul><p>A Predicate is on the form <tt>[PredicateExpr]</tt> where
 PredicateExpr currently can be in any of the following forms:</p>
<ul>
<li><p>An integer indexes one item in the selected set, according to
   the document order. A negative index counts from the end of
   the set.</p>
</li><li><p>A RelativeLocationPath as specified above. It's executed for
   each element in the selected set and those where it yields an
   empty result are filtered out while the rest remain in the
   set.</p>
</li><li><p>A RelativeLocationPath as specified above followed by
   <tt>="value"</tt>. The path is executed for each element in the
   selected set and those where the text result of it is equal to
   the given value remain in the set. Either <tt>'</tt> or <tt>"</tt>
   may be used to delimit the value.</p>
</li></ul><p>If <font face='courier'>xml_format</font>  is nonzero, the return value is an xml
 formatted string of all the matched nodes, in document order.
 Otherwise the return value is as follows:</p>
<p> Attributes are returned as one or more index/value pairs in a
 mapping. Other nodes are returned as the node objects. If the
 expression is on a form that can give at most one answer (i.e.
 there's a predicate with an integer index) then a single mapping
 or node is returned, or zero if there was no match. If the
 expression can give more answers then the return value is an
 array containing zero or more attribute mappings and/or nodes.
 The array follows document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>xml_format</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>xml_format</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the formatted XML that corresponds to the node tree.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.NodeWithChildElements</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Node with child elements.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>NodeWithChildren</b></font>
</font><dt>
<dd><p><font face='courier'>inherit NodeWithChildren</font><font face='courier'> : <font color='#F000F0'>NodeWithChildren</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Lightweight variant of <font face='courier'>get_elements_by_tag_name</font>  that returns
 a simple array instead of a fancy live NodeList.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendant_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_descendant_elements</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all descendant elements in document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendant_nodes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Node</font>) <b><font color='#000066'>get_descendant_nodes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all descendant nodes (except attribute nodes) in
 document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.Document</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The node tree is very likely a cyclic structure, so it might be an
 good idea to destruct it when you're finished with it, to avoid
 garbage. Destructing the <font face='courier'>Document</font>  object always destroys all
 nodes in it.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>NodeWithChildElements</b></font>
</font><dt>
<dd><p><font face='courier'>inherit NodeWithChildElements</font><font face='courier'> : <font color='#F000F0'>NodeWithChildElements</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Note that this one looks among the top level elements, as
 opposed to <font face='courier'>get_elements_by_tag_name</font> . This means that if the
 document is correct, you can only look up the single top level
 element here.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_raw_values</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_raw_values</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.HTML</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a simple parser for SGML structured markups. It's not
 really HTML, but it's useful for that *! purpose.</p>
<p> The simple way to use it is to give it some information about
 available tags and containers, and what callbacks those is to
 call.</p>
<p> The object is easily reused, by calling the <font face='courier'>clone()</font>  function.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_container</font> , <font face='courier'>finish</font> </p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_set_tag_callback</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>_set_entity_callback</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>_set_data_callback</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_tag_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_entity_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_data_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>These functions set up the parser object to call the given
 callbacks upon tags, entities and/or data. The callbacks will
 <i>only</i> be called if there isn't another tag/container/entity
 handler for these.</p>
<p> The callback function will be called with the parser object as
 first argument, and the active string as second. Note that no
 parsing of the contents has been done. Both endtags and normal
 tags are called; there is no container parsing.</p>
<p> The return values from the callbacks are handled in the same way
 as the return values from callbacks registered with <font face='courier'>add_tag</font>  and
 similar functions.</p>
<p> The data callback will be called as seldom as possible with the
 longest possible string, as long as it doesn't get called out of
 order with any other callback. It will never be called with a zero
 length string.</p>
<p> If a string or array is given instead of a function, it
 will act as the return value from the function. Arrays 
 or empty strings is probably preferable to avoid recursion.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_tag</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_container</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_entity</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_quote_tag</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_entities</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_tag</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_container</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_quote_tag</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font>, <font color='#202020'>string</font> <font color='#005080'>end</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_tags</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>tags</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_containers</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>containers</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_entities</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>entities</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Registers the actions to take when parsing various things. Tags,
 containers, entities are as usual. <font face='courier'>add_quote_tag()</font>  adds a special
 kind of tag that reads any data until the next occurrence of the
 end string immediately before a tag end.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>to_do</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>This argument can be any of the following.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>function</font></tt></td><td bgcolor='white'><p>The function will be called as a callback function. It will
       get the following arguments, depending on the type of
       callback.
	<font face='courier'><pre>
 mixed tag_callback(Parser.HTML parser,mapping args,mixed ... extra)
 mixed container_callback(Parser.HTML parser,mapping args,string content,mixed ... extra)
 mixed entity_callback(Parser.HTML parser,mixed ... extra)
 mixed quote_tag_callback(Parser.HTML parser,string content,mixed ... extra)
	</pre></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font></tt></td><td bgcolor='white'><p>This tag/container/entity is then replaced by the string.
       The string is normally not reparsed, i.e. it's equivalent to
       writing a function that returns the string in an array (but
       a lot faster). If <font face='courier'>reparse_strings</font>  is set the string will
       be reparsed, though.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>array</font></tt></td><td bgcolor='white'><p>The first element is a function as above. It will receive
       the rest of the array as extra arguments. If extra arguments
       are given by <font face='courier'>set_extra()</font> , they will appear after
       the ones in this array.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(0..)</tt></td><td bgcolor='white'><p>If there is a tag/container/entity with the given name in
       the parser, it's removed.</p>
</td></tr>
</table></td></tr></table><br />
<p>The callback function can return:</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font></tt></td><td bgcolor='white'><p>This string will be pushed on the parser stack and be
       parsed. Be careful not to return anything in this way that
       could lead to a infinite recursion.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>array</font></tt></td><td bgcolor='white'><p>The element(s) of the array is the result of the function.
       This will not be parsed. This is useful for avoiding
       infinite recursion. The array can be of any size, this means
       the empty array is the most effective to return if you don't
       care about the result. If the parser is operating in
       <font face='courier'>mixed_mode</font> , the array can contain anything. Otherwise
       only strings are allowed.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(0..0)</tt></td><td bgcolor='white'><p>This means "don't do anything", ie the item that generated
       the callback is left as it is, and the parser continues.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(1..1)</tt></td><td bgcolor='white'><p>Reparse the last item again. This is useful to parse a tag
       as a container, or vice versa: just add or remove callbacks
       for the tag and return this to jump to the right callback.</p>
</td></tr>
</table></td></tr></table><br />

</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>tags</font> , <font face='courier'>containers</font> , <font face='courier'>entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clear_tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_entities</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_quote_tags</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_tags</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_containers</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_entities</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_quote_tags</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all registered definitions in the different categories.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_tags</font> , <font face='courier'>add_container</font> , <font face='courier'>add_containers</font> ,
   <font face='courier'>add_entity</font> , <font face='courier'>add_entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>entities</b></font><br />
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>tags</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>containers</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>entities</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current callback settings. When matching is done case
 insensitively, all names will be returned in lowercase.</p>
<p> Implementation note: These run in constant time since they return
 copy-on-write mappings.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_tags</font> , <font face='courier'>add_container</font> , <font face='courier'>add_containers</font> ,
   <font face='courier'>add_entity</font> , <font face='courier'>add_entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>quote_tags</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>array</font>(<font color='#202020'>mixed</font>|<font color='#202020'>string</font>)) <b><font color='#000066'>quote_tags</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current callback settings. The values are arrays
 ({callback, end_quote}). When matching is done case insensitively,
 all names will be returned in lowercase.</p>
<p> Implementation note: <font face='courier'>quote_tags()</font>  allocates a new mapping for
 every call and thus, unlike e.g. <font face='courier'>tags()</font>  runs in linear time.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_quote_tag</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>feed</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>do_parse</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Feed new data to the <font face='courier'>Parser.HTML</font>  object. This will start a scan
 and may result in callbacks. Note that it's possible that all data
 fed isn't processed - to do that, call <font face='courier'>finish()</font> .</p>
<p> If the function is called without arguments, no data is fed, but
 the parser is run. If the string argument is followed by a
 <font face='courier'><code>0</code></font>, <font face='courier'><code>-&gt;feed(s,0);</code></font>, the string is fed, but the parser
 isn't run.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>finish</font> , <font face='courier'>read</font> , <font face='courier'>feed_insert</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>feed_insert</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed_insert</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This pushes a string on the parser stack.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Don't use!</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>finish</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>finish</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>finish</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Finish a parser pass. A string may be sent here, similar to
 feed().</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>read</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font>|<font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <b><font color='#000066'>read</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>string</font>|<font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <b><font color='#000066'>read</font>(</b><font color='#202020'>int</font> <font color='#005080'>max_elems</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Read parsed data from the parser object.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a string of parsed data if the parser isn't in
   <font face='courier'>mixed_mode</font> , an array of arbitrary data otherwise.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>write_out</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>write_out</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Send data to the output stream, i.e. it won't be parsed and it
 won't be sent to the data callback, if any.</p>
<p> Any data is allowed when the parser is running in <font face='courier'>mixed_mode</font> .
 Only strings are allowed otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>at</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_line</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_char</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_column</b></font><br />
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>int</font>) <b><font color='#000066'>at</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_line</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_char</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_column</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current position. Characters and columns count from
 <font face='courier'><code>0</code></font>, lines count from <font face='courier'><code>1</code></font>.</p>
<p><font face='courier'>at()</font>  gives an array with the following layout.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white' colspan='2'>Array</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>0</font></tt></td><td bgcolor='white'><p>Line.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>1</font></tt></td><td bgcolor='white'><p>Character.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>2</font></tt></td><td bgcolor='white'><p>Column.</p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>current</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>current</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the current range of data, ie the whole tag/entity/etc being
 parsed in the current callback. Returns zero if there's no current
 range, i.e. when the function is not called in a callback.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the name of the current tag, or zero. If used from an entity
 callback, it gives the string inside the entity.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_args</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>tag_args</font>(</b><font color='#202020'>void</font>|<font color='#202020'>mixed</font> <font color='#005080'>default_value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the arguments of the current tag, parsed to a convenient
 mapping consisting of key:value pairs. If the current thing isn't
 a tag, it gives zero. <font face='courier'>default_value</font>  is used for arguments which
 have no value in the tag. If <font face='courier'>default_value</font>  isn't given, the
 value is set to the same string as the key.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_content</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>tag_content</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the content of the current tag, if it's a container or quote
 tag. Otherwise returns zero.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>mixed</font> <font color='#005080'>default_value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the equivalent of the following calls.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white' colspan='2'>Array</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font> <font color='green'>0</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_name()</code></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='green'>1</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_args(default_value)</code></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font> <font color='green'>2</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_content()</code></font></p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>context</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>context</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current output context as a string.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"data"</font></tt></td><td bgcolor='white'><p>In top level data. This is always returned when called from
     tag or container callbacks.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"arg"</font></tt></td><td bgcolor='white'><p>In an unquoted argument.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"splice_arg"</font></tt></td><td bgcolor='white'><p>In a splice argument.</p>
</td></tr>
</table></td></tr></table><br />
<p>The return value can also be a single character string, in which
 case the context is a quoted argument. The string contains the
 starting quote character.</p>
<p> This function is typically only useful in entity callbacks, which
 can be called both from text and argument values of different
 sorts.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>splice_arg</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>parse_tag_name</font>(</b><font color='#202020'>string</font> <font color='#005080'>tag</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parses the tag name from a tag string without the surrounding
 brackets, i.e. a string on the form <font face='courier'><code>"tagname&nbsp;some='tag'
&nbsp;args"</code></font>.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the tag name or an empty string if none.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_tag_args</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>parse_tag_args</font>(</b><font color='#202020'>string</font> <font color='#005080'>tag</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parses the tag arguments from a tag string without the name and
 surrounding brackets, i.e. a string on the form <font face='courier'><code>"some='tag'
&nbsp;args"</code></font>.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a mapping containing the tag arguments.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>tag_args</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_inspect</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>_inspect</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a low-level way of debugging a parser. This gives a
 mapping of the internal state of the Parser.HTML object.</p>
<p> The format and contents of this mapping may change without further
 notice.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clone</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clones the <font face='courier'>Parser.HTML</font>  object. A new object of the same class
 is created, filled with the parse setup from the old object.</p>
<p> This is the simpliest way of flushing a parse feed/output.</p>
<p> The arguments to clone is sent to the new object, simplifying work
 for custom classes that inherits <font face='courier'>Parser.HTML</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new object.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>create is called _before_ the setup is copied.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_extra</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>set_extra</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the extra arguments passed to all tag, container and entity
 callbacks.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_extra</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>get_extra</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gets the extra arguments set by <font face='courier'>set_extra()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>splice_arg</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>splice_arg</font>(</b><font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If given a string, it sets the splice argument name to it. It
 returns the old splice argument name.</p>
<p> If a splice argument name is set, it's parsed in all tags, both
 those with callbacks and those without. Wherever it occurs, its
 value (after being parsed for entities in the normal way) is
 inserted directly into the tag. E.g:</p>
<p><font face='courier'><pre>&lt;foo arg1="val 1" splice="arg2='val 2' arg3" arg4&gt;</pre></font></p>
<p> becomes</p>
<p><font face='courier'><pre>&lt;foo arg1="val 1" arg2='val 2' arg3 arg4&gt;</pre></font></p>
<p> if <font face='courier'><code>"splice"</code></font> is set as the splice argument name.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>case_insensitive_tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>case_insensitive_tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>All tags and containers are matched case insensitively, and
 argument names are converted to lowercase. Tags added with
 <font face='courier'>add_quote_tag()</font>  are not affected, though. Switching to case
 insensitive mode and back won't preserve the case of registered
 tags and containers.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_tags</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_tags</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Do not look for tags at all. Normally tags are matched even when
 there's no callbacks for them at all. When this is set, the tag
 delimiters <font face='courier'><code>'&lt;'</code></font> and <font face='courier'><code>'&gt;'</code></font> will be treated as any
 normal character.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_unknown</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_unknown</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Treat unknown tags and entities as text data, continuing parsing
 for tags and entities inside them.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>When functions are specified with <font face='courier'>_set_tag_callback()</font>  or
   <font face='courier'>_set_entity_callback()</font> , all tags or entities, respectively,
   are considered known. However, if one of those functions return
   1 and ignore_unknown is set, they are treated as text data
   instead of making another call to the same function again.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lazy_argument_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>lazy_argument_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A <font face='courier'><code>'&gt;'</code></font> in a tag argument closes both the argument and the
 tag, even if the argument is quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lazy_entity_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>lazy_entity_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Normally, the parser search indefinitely for the entity end
 character (i.e. <font face='courier'><code>';'</code></font>). When this flag is set, the
 characters <font face='courier'><code>'&amp;'</code></font>, <font face='courier'><code>'&lt;'</code></font>, <font face='courier'><code>'&gt;'</code></font>, <font face='courier'><code>'"'</code></font>,
 <font face='courier'><code>'''</code></font>, and any whitespace breaks the search for the entity
 end, and the entity text is then ignored, i.e. treated as
 data.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>match_tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>match_tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Unquoted nested tag starters and enders will be balanced when
 parsing tags. This is the default.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>max_parse_depth</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>max_parse_depth</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Maximum recursion depth during parsing. Recursion occurs when a
 tag/container/entity/quote tag callback function returns a string
 to be reparsed. The default value is <font face='courier'><code>10</code></font>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>mixed_mode</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>mixed_mode</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Allow callbacks to return arbitrary data in the arrays, which will
 be concatenated in the output.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>reparse_strings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>reparse_strings</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>When a plain string is used as a tag/container/entity/quote tag
 callback, it's not reparsed if this flag is unset. Setting it
 causes all such strings to be reparsed.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ws_before_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ws_before_tag_name</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Allow whitespace between the tag start character and the tag
 name.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>xml_tag_syntax</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>xml_tag_syntax</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Whether or not to use XML syntax to tell empty tags and container
 tags apart.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>0</font></tt></td><td bgcolor='white'><p>Use HTML syntax only. If there's a <font face='courier'><code>'/'</code></font> last in a tag,
     it's just treated as any other argument.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>1</font></tt></td><td bgcolor='white'><p>Use HTML syntax, but ignore a <font face='courier'><code>'/'</code></font> if it comes last in
     a tag. This is the default.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>2</font></tt></td><td bgcolor='white'><p>Use XML syntax, but when a tag that does not end with
     <font face='courier'><code>'/&gt;'</code></font> is found which only got a non-container tag
     callback, treat it as a non-container (i.e. don't start to
     seek for the container end).</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>3</font></tt></td><td bgcolor='white'><p>Use XML syntax only. If a tag got both container and
     non-container callbacks, the non-container callback is called
     when the empty element form (i.e. the one ending with
     <font face='courier'><code>'/&gt;'</code></font>) is used, and the container callback otherwise.
     If only a container callback exists, it gets the empty string
     as content when there's none to be parsed. If only a
     non-container callback exists, it will be called (without the
     content argument) for both kinds of tags.</p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>nestling_entity_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>nestling_entity_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_comments</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_comments</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>
</dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser</b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_xml_parser</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>HTML</font> <b><font color='#000066'>get_xml_parser</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a <font face='courier'>Parser.HTML</font>  initialized for parsing XML. It has all
 the flags set properly for XML syntax and callbacks to ignore
 comments, CDATA blocks and unknown PI tags, but it has no
 registered tags and doesn't decode any entities.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>decode_numeric_xml_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>decode_numeric_xml_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>chref</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Decodes the numeric XML entity <font face='courier'>chref</font> , e.g. <tt>"&amp;#x34;"</tt> and
 returns the character as a string. <font face='courier'>chref</font>  is the name part of
 the entity, i.e. without the leading '&amp;' and trailing ';'. Returns
 zero if <font face='courier'>chref</font>  isn't on a recognized form or if the character
 number is too large to be represented in a string.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>html_entity_parser</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>parse_html_entities</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>HTML</font> <b><font color='#000066'>html_entity_parser</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>string</font> <b><font color='#000066'>parse_html_entities</font>(</b><font color='#202020'>string</font> <font color='#005080'>in</font><b>)</b></tt><br />
<tt><font color='#005080'>HTML</font> <b><font color='#000066'>html_entity_parser</font>(</b><font color='#202020'>int</font> <font color='#005080'>noerror</font><b>)</b></tt><br />
<tt><font color='#202020'>string</font> <b><font color='#000066'>parse_html_entities</font>(</b><font color='#202020'>string</font> <font color='#005080'>in</font>, <font color='#202020'>int</font> <font color='#005080'>noerror</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parse any HTML entities in the string to unicode characters.
	Either return a complete parser (to build on or use) or parse
	a string. Throw an error if there is an unrecognized entity in
	the string if noerror is not set.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Currently using XHTML 1.0 tables.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>encode_html_entities</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>encode_html_entities</font>(</b><font color='#202020'>string</font> <font color='#005080'>raw</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Encode characters to HTML entities, e.g. turning <font face='courier'><code>"&lt;"</code></font> into
 <font face='courier'><code>"&amp;lt;"</code></font>.</p>
<p> The characters that will be encoded are characters &lt;= 32,
 <font face='courier'><code>"\"&amp;'&lt;&gt;"</code></font> and characters &gt;= 127 and &lt;= 160 and characters
 &gt;= 255.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.SGML</font></b></font></td></tr></table><br />
</dt><dd><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.SGML.SGML</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a handy simple parser of SGML-like
	syntax like HTML. It doesn't do anything advanced,
	but finding the corresponding end-tags.</p>
<p>	It's used like this:</p>
<font face='courier'><pre><code><dd><p>array res=Parser.SGML()-&gt;feed(string)-&gt;finish()-&gt;result();</p>
</dd>
</code></pre></font><p>The resulting structure is an array of atoms,
	where the atom can be a string or a tag.
	A tag contains a similar array, as data.</p>
</font></dd>
<dt><font face='Helvetica'>Example</font><dt>
<dd><pre><p>A string
     <font face='courier'><code>"&lt;gat&gt;&amp;nbsp;&lt;gurka&gt;&amp;nbsp;&lt;/gurka&gt;&amp;nbsp;&lt;banan&gt;&amp;nbsp;&lt;kiwi&gt;&amp;nbsp;&lt;/gat&gt;"</code></font>
     results in</p>
<font face='courier'><pre><code><dd><p>({
    tag "gat" object with data:
    ({
        tag "gurka" object with data:
	({
            " "
        })
        tag "banan" object with data:
	({
            " "
            tag "kiwi" object with data:
	    ({
               " "
            })
        })
    })
})</p>
</dd>
</code></pre></font><p>ie, simple "tags" (not containers) are not detected,
	but containers are ended implicitely by a surrounding
	container _with_ an end tag.</p>
<p> 	The 'tag' is an object with the following variables:
	<font face='courier'><pre>
	 string name;           - name of tag
	 mapping args;          - argument to tag
	 int line,char,column;  - position of tag
	 string file;           - filename (see &lt;ref&gt;create&lt;/ref&gt;)
	 array(SGMLatom) data;  - contained data
     </pre></font></p>
</pre></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>file</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.SGML.SGML.<b><font color='#F000F0'>file</font></b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.SGML.SGML<b>(</b><b>)</b></tt><br />
<tt><font color='#202020'>void</font> Parser.SGML.SGML<b>(</b><font color='#202020'>string</font> <font color='#005080'>filename</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This object is created with this filename.
	It's passed to all created tags, for debug and trace purposes.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>No, it doesn't read the file itself. See <font face='courier'>feed()</font> .</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>feed</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>finish</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>result</b></font><br />
</font><dt>
<dd><p><tt><font color='#202020'>object</font> <b><font color='#000066'>feed</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt><br />
<tt><font color='#202020'>array</font>(<font color='#005080'>SGMLatom</font>|<font color='#202020'>string</font>) <b><font color='#000066'>finish</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>array</font>(<font color='#005080'>SGMLatom</font>|<font color='#202020'>string</font>) <b><font color='#000066'>result</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Feed new data to the object, or finish the stream.
	No result can be used until <font face='courier'>finish()</font>  is called.</p>
<p> 	Both <font face='courier'>finish()</font>  and <font face='courier'>result()</font>  return the computed data.</p>
<p><font face='courier'>feed()</font>  returns the called object.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.SGML.SGML.SGMLatom</font></b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'></font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>name</font></b></tt><br />
<tt><font color='#202020'>mapping</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>args</font></b></tt><br />
<tt><font color='#202020'>int</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>line</font></b></tt><br />
<tt><font color='#202020'>int</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>char</font></b></tt><br />
<tt><font color='#202020'>int</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>column</font></b></tt><br />
<tt><font color='#202020'>string</font> Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>file</font></b></tt><br />
<tt><font color='#202020'>array</font>(<font color='#005080'>SGMLatom</font>) Parser.SGML.SGML.SGMLatom.<b><font color='#F000F0'>data</font></b></tt></p></dd>
</dl>
</dd></dl></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.RCS</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A RCS file parser that eats a RCS *,v file and presents nice pike
 data structures of its contents.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>_RCS</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Parser._RCS</font><font face='courier'> : <font color='#F000F0'>_RCS</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>head</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.<b><font color='#F000F0'>head</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Version number of the head version of the file</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>branch</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font>|<font color='#202020'>int</font>(0..0) Parser.RCS.<b><font color='#F000F0'>branch</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The default branch (or revision), if present, <font face='courier'><code>0</code></font> otherwise</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>access</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>) Parser.RCS.<b><font color='#F000F0'>access</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The usernames listed in the ACCESS section of the RCS file</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>comment</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font>|<font color='#202020'>int</font>(0..0) Parser.RCS.<b><font color='#F000F0'>comment</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The RCS file comment if present, <font face='courier'><code>0</code></font> otherwise</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>expand</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.<b><font color='#F000F0'>expand</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The keyword expansion options (as named by RCS) if present,
 <font face='courier'><code>0</code></font> otherwise</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>description</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.<b><font color='#F000F0'>description</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The RCS file description</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>locks</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) Parser.RCS.<b><font color='#F000F0'>locks</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Maps from username to revision for users that have acquired locks
 on this file</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>strict_locks</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>(0..1) Parser.RCS.<b><font color='#F000F0'>strict_locks</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>1 if strict locking is set, 0 otherwise</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>tags</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) Parser.RCS.<b><font color='#F000F0'>tags</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Maps tag names (indices) to tagged revision numbers (values)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>branches</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) Parser.RCS.<b><font color='#F000F0'>branches</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Maps branch numbers (indices) to branch names (values)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>revisions</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#005080'>Revision</font>) Parser.RCS.<b><font color='#F000F0'>revisions</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Data for all revisions of the file. The indices of the mapping are
 the revision numbers, whereas the values are the data from the
 corresponding revision.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>trunk</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>mapping</font>) Parser.RCS.<b><font color='#F000F0'>trunk</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Data for all revisions on the trunk, sorted in the same order as the
 RCS file stored them - ie descending, most recent first, I'd assume
 (rcsfile(5), of course, fails to state such irrelevant information).</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.RCS<b>(</b><font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>file_name</font>, <font color='#202020'>string</font>|<font color='#202020'>int</font>(0..0)|<font color='#202020'>void</font> <font color='#005080'>file_contents</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Initializes the RCS object.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>file_name</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The path to the raw RCS file (includes trailing ",v"). Used
   mainly for error reporting (truncated RCS file).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>file_contents</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If a string is provided, that string will be parsed to
   initialize the RCS object. If a zero (<font face='courier'><code>0</code></font>) is sent, no
   initialization will be performed at all. If no value is given at
   all, but <font face='courier'>file_name</font>  was provided, that file will be loaded and
   parsed for object initialization.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_admin_section</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse_admin_section</font>(</b><font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>raw</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Lower-level API function for parsing only the admin section (the
 initial chunk of an RCS file, see manpage rcsfile(5)) of an RCS
 file. After running <font face='courier'>parse_admin_section</font> , the RCS object will be
 initialized with the values for <font face='courier'>head</font> , <font face='courier'>branch</font> , <font face='courier'>access</font> ,
 <font face='courier'>branches</font> , <font face='courier'>tokenize</font> , <font face='courier'>tags</font> , <font face='courier'>locks</font> , <font face='courier'>strict_locks</font> ,
 <font face='courier'>comment</font>  and <font face='courier'>expand</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The tokenized RCS file, or the raw RCS-file data.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The rest of the RCS file, admin section removed.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse_delta_sections</font> , <font face='courier'>parse_deltatext_sections</font> , <font face='courier'>parse</font> , <font face='courier'>create</font> </p>
</font></dd><dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Does not handle rcsfile(5) newphrase skipping.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_delta_sections</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse_delta_sections</font>(</b><font color='#202020'>array</font> <font color='#005080'>raw</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Lower-level API function for parsing only the delta sections (the
 second chunk of an RCS file, see manpage rcsfile(5)) of an RCS
 file. After running <font face='courier'>parse_delta_sections</font> , the RCS object will
 be initialized with the value of <font face='courier'>description</font>  and populated
 <font face='courier'>revisions</font>  mapping and <font face='courier'>trunk</font>  array. Their <font face='courier'>Revision</font>  members
 are however only populated with the members <font face='courier'>Revision-&gt;revision</font> ,
 <font face='courier'>Revision-&gt;branch</font> , <font face='courier'>Revision-&gt;time</font> , <font face='courier'>Revision-&gt;author</font> ,
 <font face='courier'>Revision-&gt;state</font> , <font face='courier'>Revision-&gt;branches</font> , <font face='courier'>Revision-&gt;rcs_next</font> ,
 <font face='courier'>Revision-&gt;ancestor</font>  and <font face='courier'>Revision-&gt;next</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The tokenized RCS file, with admin section removed. (See
   <font face='courier'>parse_admin_section</font> .)</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The rest of the RCS file, delta sections removed.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse_admin_section</font> , <font face='courier'>tokenize</font> , <font face='courier'>parse_deltatext_sections</font> ,
   <font face='courier'>parse</font> , <font face='courier'>create</font> </p>
</font></dd><dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Does not handle rcsfile(5) newphrase skipping.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tokenize</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>array</font>(<font color='#202020'>string</font>)) <b><font color='#000066'>tokenize</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Tokenize an RCS file into tokens suitable as argument to the various
 parse functions</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>data</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The RCS file data</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>An array with arrays of tokens</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_deltatext_sections</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>parse_deltatext_sections</font>(</b><font color='#202020'>array</font> <font color='#005080'>raw</font>, <font color='#202020'>void</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>void</font>) <font color='#005080'>progress_callback</font>, <font color='#202020'>array</font>|<font color='#202020'>void</font> <font color='#005080'>callback_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Lower-level API function for parsing only the deltatext sections
 (the final and typically largest chunk of an RCS file, see manpage
 rcsfile(5)) of an RCS file. After a <font face='courier'>parse_deltatext_sections</font> 
 run, the RCS object will be fully populated.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The tokenized RCS file, with admin and delta sections removed.
   (See <font face='courier'>parse_admin_section</font> , <font face='courier'>tokenize</font>  and <font face='courier'>parse_delta_sections</font> .)</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>progress_callback</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>This optional callback is invoked with the revision of the
   deltatext about to be parsed (useful for progress indicators).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>args</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Optional extra trailing arguments to be sent to <font face='courier'>progress_callback</font> </p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse_admin_section</font> , <font face='courier'>parse_delta_sections</font> , <font face='courier'>parse</font> , <font face='courier'>create</font> </p>
</font></dd><dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Does not handle rcsfile(5) newphrase skipping.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>this_program</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>array</font> <font color='#005080'>raw</font>, <font color='#202020'>void</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>void</font>) <font color='#005080'>progress_callback</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parse the RCS file <font face='courier'>raw</font>  and initialize all members of this object
 fully initialized.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The unprocessed RCS file.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>progress_callback</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Passed on to <font face='courier'>parse_deltatext_sections</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The fully initialized object (only returned for API convenience;
   the object itself is destructively modified to match the data
   extracted from <font face='courier'>raw</font> )</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse_admin_section</font> , <font face='courier'>parse_delta_sections</font> ,
   <font face='courier'>parse_deltatext_sections</font> , <font face='courier'>create</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_contents_for_revision</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_contents_for_revision</font>(</b><font color='#202020'>string</font>|<font color='#005080'>Revision</font> <font color='#005080'>rev</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the file contents from the revision <font face='courier'>rev</font> , without performing
 any keyword expansion.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>expand_keywords_for_revision</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>expand_keywords_for_revision</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>expand_keywords_for_revision</font>(</b><font color='#202020'>string</font>|<font color='#005080'>Revision</font> <font color='#005080'>rev</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>text</font>, <font color='#202020'>int</font>|<font color='#202020'>void</font> <font color='#005080'>override_binary</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Expand keywords and return the resulting text according to the
 expansion rules set for the file.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>rev</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The revision to apply the expansion for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>text</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If supplied, substitute keywords for that text instead using values that
   would apply for the given revision. Otherwise, revision <font face='courier'>rev</font>  is used.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>override_binary</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If 1, perform expansion even if the file was checked in as binary.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The Log keyword (which lacks sane quoting rules) is not
   expanded. Keyword expansion rules set in CVSROOT/cvswrappers
   are ignored. Only implements the -kkv and -kb expansion modes.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>get_contents_for_revision</font> </p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.RCS.DeltatextIterator</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Iterator for the deltatext sections of the RCS file. Typical usage:</p>
</font></dd>
<dt><font face='Helvetica'>Example</font><dt>
<dd><pre><p>string raw = Stdio.read_file(my_rcs_filename);
   Parser.RCS rcs = Parser.RCS(my_rcs_filename, 0);
   raw = rcs-&gt;parse_delta_sections(rcs-&gt;parse_admin_section(raw));
   foreach(rcs-&gt;DeltatextIterator(raw); int n; Parser.RCS.Revision rev)
     do_something(rev);</p>
</pre></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.RCS.DeltatextIterator<b>(</b><font color='#202020'>array</font> <font color='#005080'>deltatext_section</font>, <font color='#202020'>void</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>void</font>) <font color='#005080'>progress_callback</font>, <font color='#202020'>void</font>|<font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <font color='#005080'>progress_callback_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>deltatext_section</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>the deltatext section of the RCS file in its entirety</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>progress_callback</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>This optional callback is invoked with the revision of the
   deltatext about to be parsed (useful for progress indicators).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>progress_callback_args</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Optional extra trailing arguments to be sent to <font face='courier'>progress_callback</font> </p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p>the <tt>rcsfile(5)</tt> manpage outlines the sections of an RCS file</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'>syntax</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.RCS.DeltatextIterator.<b><font color='#F000F0'>n</font></b></tt><tt><font color='#202020'>int</font>(0..1) <b><font color='#000066'>read_next</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Drops the leading whitespace before next revision's deltatext
 entry and sets this_rev to the revision number we're about to read.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>index</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>index</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>the number of deltatext entries processed so far (0..N-1, N
 being the total number of revisions in the rcs file)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>value</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Revision</font> <b><font color='#000066'>value</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>the <font face='courier'>Revision</font>  at whose deltatext data we are, updated with its info</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`!</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>(0..1) <b><font color='#000066'>`!</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>1 if the iterator has processed all deltatext entries, 0 otherwise.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`+=</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>this_program</font> <b><font color='#000066'>`+=</font>(</b><font color='#202020'>int</font> <font color='#005080'>nsteps</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Advance <font face='courier'>nsteps</font>  sections.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the iterator object.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>next</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>(0..1) <b><font color='#000066'>next</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>like <font face='courier'><code><font&nbsp;face='courier'>`+=</font>&nbsp;(1)</code></font>, but returns 0 if the iterator is finished</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>first</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>(0..1) <b><font color='#000066'>first</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Restart not implemented; always returns 0 (==failed)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_deltatext_section</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>parse_deltatext_section</font>(</b><font color='#202020'>array</font> <font color='#005080'>raw</font>, <font color='#202020'>int</font> <font color='#005080'>o</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Chops off the first deltatext section from the token array <font face='courier'>raw</font>  and
 returns the rest of the string, or the value <font face='courier'><code>0</code></font> (zero) if
 we had already visited the final deltatext entry. The deltatext's
 data is stored destructively in the appropriate entry of the
 <font face='courier'>revisions</font>  array.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>raw</font> +<font face='courier'>o</font>  must start with a deltatext entry for this method to work</p>
</font></dd><dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>does not handle rcsfile(5) newphrase skipping</p>
</font></dd><dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>if the rcs file is truncated, this method writes a descriptive
   error to stderr and then returns 0 - some nicer error handling
   wouldn't hurt</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.RCS.Revision</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>All data tied to a particular revision of the file.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>revision</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>revision</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the revision number (i e <font face='courier'>RCS</font> -&gt;revisions["1.1"]-&gt;revision == "1.1")</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>author</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>author</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the name of the user that committed the revision</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>branches</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>) Parser.RCS.Revision.<b><font color='#F000F0'>branches</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>when there are branches from this revision, an array of the
 revision numbers where each branch starts, otherwise 0</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>state</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>state</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the state of the revision - typically "Exp" or "dead"</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>time</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Calendar.TimeRange</font> Parser.RCS.Revision.<b><font color='#F000F0'>time</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the (UTC) date and time when the revision was committed (second
 precision)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>branch</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>branch</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the branch name on which this revision was committed (calculated
 according to how cvs manages branches)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>rcs_next</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>rcs_next</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the revision stored next in the rcs file, or 0 if none exists</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>ancestor</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>ancestor</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the revision of the ancestor of this revision, or 0 if this was
 the initial revision</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>next</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>next</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the revision that succeeds this revision, or 0 if none exists</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>log</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.RCS.Revision.<b><font color='#F000F0'>log</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the log message associated with the revision</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>lines</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.RCS.Revision.<b><font color='#F000F0'>lines</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the number of lines this revision contained, altogether (not of
 particular interest for binary files)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>added</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.RCS.Revision.<b><font color='#F000F0'>added</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the number of lines that were added from the previous revision
 to make this revision (for the initial revision too)</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>removed</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.RCS.Revision.<b><font color='#F000F0'>removed</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>the number of lines that were removed from the previous revision
 to make this revision</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.HTML</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a simple parser for SGML structured markups. It's not
 really HTML, but it's useful for that *! purpose.</p>
<p> The simple way to use it is to give it some information about
 available tags and containers, and what callbacks those is to
 call.</p>
<p> The object is easily reused, by calling the <font face='courier'>clone()</font>  function.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_container</font> , <font face='courier'>finish</font> </p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_set_tag_callback</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>_set_entity_callback</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>_set_data_callback</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_tag_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_entity_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>_set_data_callback</font>(</b><font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>array</font> <font color='#005080'>to_call</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>These functions set up the parser object to call the given
 callbacks upon tags, entities and/or data. The callbacks will
 <i>only</i> be called if there isn't another tag/container/entity
 handler for these.</p>
<p> The callback function will be called with the parser object as
 first argument, and the active string as second. Note that no
 parsing of the contents has been done. Both endtags and normal
 tags are called; there is no container parsing.</p>
<p> The return values from the callbacks are handled in the same way
 as the return values from callbacks registered with <font face='courier'>add_tag</font>  and
 similar functions.</p>
<p> The data callback will be called as seldom as possible with the
 longest possible string, as long as it doesn't get called out of
 order with any other callback. It will never be called with a zero
 length string.</p>
<p> If a string or array is given instead of a function, it
 will act as the return value from the function. Arrays 
 or empty strings is probably preferable to avoid recursion.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_tag</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_container</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_entity</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_quote_tag</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>add_entities</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_tag</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_container</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_quote_tag</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mixed</font> <font color='#005080'>to_do</font>, <font color='#202020'>string</font> <font color='#005080'>end</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_tags</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>tags</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_containers</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>containers</font><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>add_entities</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>entities</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Registers the actions to take when parsing various things. Tags,
 containers, entities are as usual. <font face='courier'>add_quote_tag()</font>  adds a special
 kind of tag that reads any data until the next occurrence of the
 end string immediately before a tag end.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>to_do</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>This argument can be any of the following.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>function</font></tt></td><td bgcolor='white'><p>The function will be called as a callback function. It will
       get the following arguments, depending on the type of
       callback.
	<font face='courier'><pre>
 mixed tag_callback(Parser.HTML parser,mapping args,mixed ... extra)
 mixed container_callback(Parser.HTML parser,mapping args,string content,mixed ... extra)
 mixed entity_callback(Parser.HTML parser,mixed ... extra)
 mixed quote_tag_callback(Parser.HTML parser,string content,mixed ... extra)
	</pre></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font></tt></td><td bgcolor='white'><p>This tag/container/entity is then replaced by the string.
       The string is normally not reparsed, i.e. it's equivalent to
       writing a function that returns the string in an array (but
       a lot faster). If <font face='courier'>reparse_strings</font>  is set the string will
       be reparsed, though.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>array</font></tt></td><td bgcolor='white'><p>The first element is a function as above. It will receive
       the rest of the array as extra arguments. If extra arguments
       are given by <font face='courier'>set_extra()</font> , they will appear after
       the ones in this array.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(0..)</tt></td><td bgcolor='white'><p>If there is a tag/container/entity with the given name in
       the parser, it's removed.</p>
</td></tr>
</table></td></tr></table><br />
<p>The callback function can return:</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font></tt></td><td bgcolor='white'><p>This string will be pushed on the parser stack and be
       parsed. Be careful not to return anything in this way that
       could lead to a infinite recursion.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>array</font></tt></td><td bgcolor='white'><p>The element(s) of the array is the result of the function.
       This will not be parsed. This is useful for avoiding
       infinite recursion. The array can be of any size, this means
       the empty array is the most effective to return if you don't
       care about the result. If the parser is operating in
       <font face='courier'>mixed_mode</font> , the array can contain anything. Otherwise
       only strings are allowed.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(0..0)</tt></td><td bgcolor='white'><p>This means "don't do anything", ie the item that generated
       the callback is left as it is, and the parser continues.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font>(1..1)</tt></td><td bgcolor='white'><p>Reparse the last item again. This is useful to parse a tag
       as a container, or vice versa: just add or remove callbacks
       for the tag and return this to jump to the right callback.</p>
</td></tr>
</table></td></tr></table><br />

</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>tags</font> , <font face='courier'>containers</font> , <font face='courier'>entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clear_tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_entities</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>clear_quote_tags</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_tags</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_containers</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_entities</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clear_quote_tags</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all registered definitions in the different categories.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_tags</font> , <font face='courier'>add_container</font> , <font face='courier'>add_containers</font> ,
   <font face='courier'>add_entity</font> , <font face='courier'>add_entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tags</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>containers</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>entities</b></font><br />
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>tags</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>containers</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>entities</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current callback settings. When matching is done case
 insensitively, all names will be returned in lowercase.</p>
<p> Implementation note: These run in constant time since they return
 copy-on-write mappings.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_tag</font> , <font face='courier'>add_tags</font> , <font face='courier'>add_container</font> , <font face='courier'>add_containers</font> ,
   <font face='courier'>add_entity</font> , <font face='courier'>add_entities</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>quote_tags</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>array</font>(<font color='#202020'>mixed</font>|<font color='#202020'>string</font>)) <b><font color='#000066'>quote_tags</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current callback settings. The values are arrays
 ({callback, end_quote}). When matching is done case insensitively,
 all names will be returned in lowercase.</p>
<p> Implementation note: <font face='courier'>quote_tags()</font>  allocates a new mapping for
 every call and thus, unlike e.g. <font face='courier'>tags()</font>  runs in linear time.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>add_quote_tag</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>feed</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>do_parse</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Feed new data to the <font face='courier'>Parser.HTML</font>  object. This will start a scan
 and may result in callbacks. Note that it's possible that all data
 fed isn't processed - to do that, call <font face='courier'>finish()</font> .</p>
<p> If the function is called without arguments, no data is fed, but
 the parser is run. If the string argument is followed by a
 <font face='courier'><code>0</code></font>, <font face='courier'><code>-&gt;feed(s,0);</code></font>, the string is fed, but the parser
 isn't run.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>finish</font> , <font face='courier'>read</font> , <font face='courier'>feed_insert</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>feed_insert</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>feed_insert</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This pushes a string on the parser stack.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Don't use!</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>finish</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>finish</font>(</b><b>)</b></tt><br />
<tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>finish</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Finish a parser pass. A string may be sent here, similar to
 feed().</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>read</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font>|<font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <b><font color='#000066'>read</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>string</font>|<font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <b><font color='#000066'>read</font>(</b><font color='#202020'>int</font> <font color='#005080'>max_elems</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Read parsed data from the parser object.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a string of parsed data if the parser isn't in
   <font face='courier'>mixed_mode</font> , an array of arbitrary data otherwise.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>write_out</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>write_out</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Send data to the output stream, i.e. it won't be parsed and it
 won't be sent to the data callback, if any.</p>
<p> Any data is allowed when the parser is running in <font face='courier'>mixed_mode</font> .
 Only strings are allowed otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>at</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_line</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_char</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>at_column</b></font><br />
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>int</font>) <b><font color='#000066'>at</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_line</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_char</font>(</b><b>)</b></tt><br />
<tt><font color='#202020'>int</font> <b><font color='#000066'>at_column</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current position. Characters and columns count from
 <font face='courier'><code>0</code></font>, lines count from <font face='courier'><code>1</code></font>.</p>
<p><font face='courier'>at()</font>  gives an array with the following layout.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white' colspan='2'>Array</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>0</font></tt></td><td bgcolor='white'><p>Line.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>1</font></tt></td><td bgcolor='white'><p>Character.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>int</font> <font color='green'>2</font></tt></td><td bgcolor='white'><p>Column.</p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>current</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>current</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the current range of data, ie the whole tag/entity/etc being
 parsed in the current callback. Returns zero if there's no current
 range, i.e. when the function is not called in a callback.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the name of the current tag, or zero. If used from an entity
 callback, it gives the string inside the entity.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_args</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <b><font color='#000066'>tag_args</font>(</b><font color='#202020'>void</font>|<font color='#202020'>mixed</font> <font color='#005080'>default_value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the arguments of the current tag, parsed to a convenient
 mapping consisting of key:value pairs. If the current thing isn't
 a tag, it gives zero. <font face='courier'>default_value</font>  is used for arguments which
 have no value in the tag. If <font face='courier'>default_value</font>  isn't given, the
 value is set to the same string as the key.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag_content</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>tag_content</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gives the content of the current tag, if it's a container or quote
 tag. Otherwise returns zero.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>mixed</font> <font color='#005080'>default_value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the equivalent of the following calls.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white' colspan='2'>Array</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font> <font color='green'>0</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_name()</code></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='green'>1</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_args(default_value)</code></font></p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='#202020'>string</font> <font color='green'>2</font></tt></td><td bgcolor='white'><p><font face='courier'><code>tag_content()</code></font></p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>context</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>context</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the current output context as a string.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"data"</font></tt></td><td bgcolor='white'><p>In top level data. This is always returned when called from
     tag or container callbacks.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"arg"</font></tt></td><td bgcolor='white'><p>In an unquoted argument.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"splice_arg"</font></tt></td><td bgcolor='white'><p>In a splice argument.</p>
</td></tr>
</table></td></tr></table><br />
<p>The return value can also be a single character string, in which
 case the context is a quoted argument. The string contains the
 starting quote character.</p>
<p> This function is typically only useful in entity callbacks, which
 can be called both from text and argument values of different
 sorts.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>splice_arg</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>parse_tag_name</font>(</b><font color='#202020'>string</font> <font color='#005080'>tag</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parses the tag name from a tag string without the surrounding
 brackets, i.e. a string on the form <font face='courier'><code>"tagname&nbsp;some='tag'
&nbsp;args"</code></font>.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the tag name or an empty string if none.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_tag_args</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>parse_tag_args</font>(</b><font color='#202020'>string</font> <font color='#005080'>tag</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parses the tag arguments from a tag string without the name and
 surrounding brackets, i.e. a string on the form <font face='courier'><code>"some='tag'
&nbsp;args"</code></font>.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a mapping containing the tag arguments.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>tag_args</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_inspect</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>_inspect</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a low-level way of debugging a parser. This gives a
 mapping of the internal state of the Parser.HTML object.</p>
<p> The format and contents of this mapping may change without further
 notice.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>clone</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clones the <font face='courier'>Parser.HTML</font>  object. A new object of the same class
 is created, filled with the parse setup from the old object.</p>
<p> This is the simpliest way of flushing a parse feed/output.</p>
<p> The arguments to clone is sent to the new object, simplifying work
 for custom classes that inherits <font face='courier'>Parser.HTML</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new object.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>create is called _before_ the setup is copied.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_extra</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser.HTML</font> <b><font color='#000066'>set_extra</font>(</b><font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the extra arguments passed to all tag, container and entity
 callbacks.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_extra</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>get_extra</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Gets the extra arguments set by <font face='courier'>set_extra()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the object being called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>splice_arg</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>splice_arg</font>(</b><font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If given a string, it sets the splice argument name to it. It
 returns the old splice argument name.</p>
<p> If a splice argument name is set, it's parsed in all tags, both
 those with callbacks and those without. Wherever it occurs, its
 value (after being parsed for entities in the normal way) is
 inserted directly into the tag. E.g:</p>
<p><font face='courier'><pre>&lt;foo arg1="val 1" splice="arg2='val 2' arg3" arg4&gt;</pre></font></p>
<p> becomes</p>
<p><font face='courier'><pre>&lt;foo arg1="val 1" arg2='val 2' arg3 arg4&gt;</pre></font></p>
<p> if <font face='courier'><code>"splice"</code></font> is set as the splice argument name.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>case_insensitive_tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>case_insensitive_tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>All tags and containers are matched case insensitively, and
 argument names are converted to lowercase. Tags added with
 <font face='courier'>add_quote_tag()</font>  are not affected, though. Switching to case
 insensitive mode and back won't preserve the case of registered
 tags and containers.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_tags</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_tags</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Do not look for tags at all. Normally tags are matched even when
 there's no callbacks for them at all. When this is set, the tag
 delimiters <font face='courier'><code>'&lt;'</code></font> and <font face='courier'><code>'&gt;'</code></font> will be treated as any
 normal character.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_unknown</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_unknown</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Treat unknown tags and entities as text data, continuing parsing
 for tags and entities inside them.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>When functions are specified with <font face='courier'>_set_tag_callback()</font>  or
   <font face='courier'>_set_entity_callback()</font> , all tags or entities, respectively,
   are considered known. However, if one of those functions return
   1 and ignore_unknown is set, they are treated as text data
   instead of making another call to the same function again.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lazy_argument_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>lazy_argument_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A <font face='courier'><code>'&gt;'</code></font> in a tag argument closes both the argument and the
 tag, even if the argument is quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lazy_entity_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>lazy_entity_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Normally, the parser search indefinitely for the entity end
 character (i.e. <font face='courier'><code>';'</code></font>). When this flag is set, the
 characters <font face='courier'><code>'&amp;'</code></font>, <font face='courier'><code>'&lt;'</code></font>, <font face='courier'><code>'&gt;'</code></font>, <font face='courier'><code>'"'</code></font>,
 <font face='courier'><code>'''</code></font>, and any whitespace breaks the search for the entity
 end, and the entity text is then ignored, i.e. treated as
 data.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>match_tag</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>match_tag</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Unquoted nested tag starters and enders will be balanced when
 parsing tags. This is the default.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>max_parse_depth</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>max_parse_depth</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Maximum recursion depth during parsing. Recursion occurs when a
 tag/container/entity/quote tag callback function returns a string
 to be reparsed. The default value is <font face='courier'><code>10</code></font>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>mixed_mode</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>mixed_mode</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Allow callbacks to return arbitrary data in the arrays, which will
 be concatenated in the output.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>reparse_strings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>reparse_strings</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>When a plain string is used as a tag/container/entity/quote tag
 callback, it's not reparsed if this flag is unset. Setting it
 causes all such strings to be reparsed.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ws_before_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ws_before_tag_name</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Allow whitespace between the tag start character and the tag
 name.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>xml_tag_syntax</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>xml_tag_syntax</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Whether or not to use XML syntax to tell empty tags and container
 tags apart.</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>0</font></tt></td><td bgcolor='white'><p>Use HTML syntax only. If there's a <font face='courier'><code>'/'</code></font> last in a tag,
     it's just treated as any other argument.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>1</font></tt></td><td bgcolor='white'><p>Use HTML syntax, but ignore a <font face='courier'><code>'/'</code></font> if it comes last in
     a tag. This is the default.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>2</font></tt></td><td bgcolor='white'><p>Use XML syntax, but when a tag that does not end with
     <font face='courier'><code>'/&gt;'</code></font> is found which only got a non-container tag
     callback, treat it as a non-container (i.e. don't start to
     seek for the container end).</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>3</font></tt></td><td bgcolor='white'><p>Use XML syntax only. If a tag got both container and
     non-container callbacks, the non-container callback is called
     when the empty element form (i.e. the one ending with
     <font face='courier'><code>'/&gt;'</code></font>) is used, and the container callback otherwise.
     If only a container callback exists, it gets the empty string
     as content when there's none to be parsed. If only a
     non-container callback exists, it will be called (without the
     content argument) for both kinds of tags.</p>
</td></tr>
</table></td></tr></table><br />
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>nestling_entity_end</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>nestling_entity_end</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>ignore_comments</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>ignore_comments</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>value</font><b>)</b></tt></p></dd>
</dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.LR</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>LALR(1) parser generator.</p>
</font></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; ENUM <b><font color='#005080'>Parser.LR.SeverityLevel</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Severity level</p>
</font></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Priority</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Specifies the priority and associativity of a rule.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>value</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Priority.<b><font color='#F000F0'>value</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Priority value</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>assoc</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Priority.<b><font color='#F000F0'>assoc</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Associativity</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>-1</font></tt></td><td bgcolor='white'><p>Left</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>0</font></tt></td><td bgcolor='white'><p>None</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>1</font></tt></td><td bgcolor='white'><p>Right</p>
</td></tr>
</table></td></tr></table><br />

</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.LR.Priority<b>(</b><font color='#202020'>int</font> <font color='#005080'>p</font>, <font color='#202020'>int</font> <font color='#005080'>a</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Create a new priority object.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>p</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Priority.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>a</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Associativity.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Rule</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This object is used to represent a BNF-rule in the LR parser.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>nonterminal</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Rule.<b><font color='#F000F0'>nonterminal</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Non-terminal this rule reduces to.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>symbols</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#202020'>int</font>) Parser.LR.Rule.<b><font color='#F000F0'>symbols</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The actual rule</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>action</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>function</font>|<font color='#202020'>string</font> Parser.LR.Rule.<b><font color='#F000F0'>action</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Action to do when reducing this rule.
 function - call this function.
 string - call this function by name in the object given to the parser.
 The function is called with arguments corresponding to the values of
 the elements of the rule. The return value of the function will be
 the value of this non-terminal. The default rule is to return the first
 argument.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>has_tokens</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Rule.<b><font color='#F000F0'>has_tokens</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This rule contains tokens</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>num_nonnullables</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Rule.<b><font color='#F000F0'>num_nonnullables</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This rule has this many non-nullable symbols at the moment.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>number</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Rule.<b><font color='#F000F0'>number</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sequence number of this rule (used for conflict resolving)
 Also used to identify the rule.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>pri</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Priority</font> Parser.LR.Rule.<b><font color='#F000F0'>pri</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Priority and associativity of this rule.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.LR.Rule<b>(</b><font color='#202020'>int</font> <font color='#005080'>nt</font>, <font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#202020'>int</font>) <font color='#005080'>r</font>, <font color='#202020'>function</font>|<font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>a</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Create a BNF rule.</p>
</font></dd>
<dt><font face='Helvetica'>Example</font><dt>
<dd><pre><p>The rule</p>
<p>	   rule : nonterminal ":" symbols ";" { add_rule };</p>
<p>   might be created as</p>
<p>	   rule(4, ({ 9, ":", 5, ";" }), "add_rule");</p>
<p>   where 4 corresponds to the nonterminal "rule", 9 to "nonterminal"
   and 5 to "symbols", and the function "add_rule" is too be called
   when this rule is reduced.</p>
</pre></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>nt</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Non-terminal to reduce to.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>r</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Symbol sequence that reduces to nt.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>a</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Action to do when reducing according to this rule.
   function - Call this function.
   string - Call this function by name in the object given to the parser.
   The function is called with arguments corresponding to the values of
   the elements of the rule. The return value of the function will become
   the value of this non-terminal. The default rule is to return the first
   argument.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.ErrorHandler</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Class handling reporting of errors and warnings.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>verbose</b></font>
</font><dt>
<dd><p><tt>optional  <font color='#202020'>int</font>(-1..1) Parser.LR.ErrorHandler.<b><font color='#F000F0'>verbose</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Verbosity level</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>-1</font></tt></td><td bgcolor='white'><p>Just errors.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>0</font></tt></td><td bgcolor='white'><p>Errors and warnings.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>1</font></tt></td><td bgcolor='white'><p>Also notices.</p>
</td></tr>
</table></td></tr></table><br />

</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.LR.ErrorHandler<b>(</b><font color='#202020'>int</font>(-1..1)|<font color='#202020'>void</font> <font color='#005080'>verbosity</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Create a new error handler.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>verbosity</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Level of verbosity.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>verbose</font> </p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Parser</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This object implements an LALR(1) parser and compiler.</p>
<p> Normal use of this object would be:</p>
<p><font face='courier'><pre>
 set_error_handler
 {add_rule, set_priority, set_associativity}*
 set_symbol_to_string
 compile
 {parse}*
 </pre></font></p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>grammar</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>int</font>:<font color='#202020'>array</font>(<font color='#005080'>Rule</font>)) Parser.LR.Parser.<b><font color='#F000F0'>grammar</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The grammar itself.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>start_state</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Kernel</font> Parser.LR.Parser.<b><font color='#F000F0'>start_state</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The initial LR0 state.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>lr_error</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.<b><font color='#F000F0'>lr_error</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Error code</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>known_states</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#005080'>Kernel</font>) Parser.LR.Parser.<b><font color='#F000F0'>known_states</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>LR0 states that are already known to the compiler.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>error_handler</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>function</font>(<font color='#005080'>SeverityLevel</font>:<font color='#202020'>void</font>) Parser.LR.Parser.<b><font color='#F000F0'>error_handler</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Compile error and warning handler.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>rule_to_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>rule_to_string</font>(</b><font color='#005080'>Rule</font> <font color='#005080'>r</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Pretty-prints a rule to a string.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>r</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Rule to print.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>item_to_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>item_to_string</font>(</b><font color='#005080'>Item</font> <font color='#005080'>i</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Pretty-prints an item to a string.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>i</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Item to pretty-print.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>state_to_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>state_to_string</font>(</b><font color='#005080'>Kernel</font> <font color='#005080'>state</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Pretty-prints a state to a string.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>state</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>State to pretty-print.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_sprintf</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>_sprintf</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Pretty-prints the current grammar to a string.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>cast</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>cast</font>(</b><font color='#202020'>string</font> <font color='#005080'>type</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Implements casting.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>type</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Type to cast to.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_priority</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_priority</font>(</b><font color='#202020'>string</font> <font color='#005080'>terminal</font>, <font color='#202020'>int</font> <font color='#005080'>pri_val</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the priority of a terminal.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>terminal</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Terminal to set the priority for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>pri_val</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Priority; higher = prefer this terminal.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_associativity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_associativity</font>(</b><font color='#202020'>string</font> <font color='#005080'>terminal</font>, <font color='#202020'>int</font> <font color='#005080'>assoc</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the associativity of a terminal.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>terminal</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Terminal to set the associativity for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>assoc</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Associativity; negative - left, positive - right,
   zero - no associativity.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_symbol_to_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_symbol_to_string</font>(</b><font color='#202020'>void</font>|<font color='#202020'>function</font>(<font color='#202020'>int</font>|<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>s_to_s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the symbol to string conversion function.
 The conversion function is used by the various *_to_string functions
 to make comprehensible output.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s_to_s</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Symbol to string conversion function.
 If zero or not specified, use the built-in function.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_error_handler</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_error_handler</font>(</b><font color='#202020'>void</font>|<font color='#202020'>function</font>(<font color='#005080'>SeverityLevel</font>:<font color='#202020'>void</font>) <font color='#005080'>handler</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the error report function.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>handler</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Function to call to report errors and warnings.
   If zero or not specifier, use the built-in function.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_rule</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>add_rule</font>(</b><font color='#005080'>Rule</font> <font color='#005080'>r</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Add a rule to the grammar.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>r</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Rule to add.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>s_q</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>StateQueue</font> Parser.LR.Parser.<b><font color='#F000F0'>s_q</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Contains all states used.
 In the queue section are the states that remain to be compiled.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>compile</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>compile</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Compiles the grammar into a parser, so that parse() can be called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>object</font>|<font color='#202020'>function</font>(<font color='#202020'>void</font>:<font color='#202020'>string</font>|<font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#202020'>mixed</font>)) <font color='#005080'>scanner</font>, <font color='#202020'>void</font>|<font color='#202020'>object</font> <font color='#005080'>action_object</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Parse the input according to the compiled grammar.
 The last value reduced is returned.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The parser must have been compiled (with compile())
   prior to calling this function.</p>
</font></dd>
<dt><font face='Helvetica'>Bugs</font><dt>
<dd><font face='Helvetica'><p>Errors should be throw()n.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>scanner</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The scanner function. It returns the next symbol from the input.
   It should either return a string (terminal) or an array with
   a string (terminal) and a mixed (value).
   EOF is indicated with the empty string.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>action_object</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Object used to resolve those actions that have been specified as
   strings.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Parser.Item</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>An LR(0) item, a partially parsed rule.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>r</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Rule</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>r</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The rule</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>offset</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>offset</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>How long into the rule the parsing has come.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>next_state</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Kernel</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>next_state</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The state we will get if we shift according to this rule</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>master_item</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Item</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>master_item</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Item representing this one (used for shifts).</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>direct_lookahead</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font>(<font color='#202020'>string</font>) Parser.LR.Parser.Item.<b><font color='#F000F0'>direct_lookahead</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Look-ahead set for this item.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>error_lookahead</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font>(<font color='#202020'>string</font>) Parser.LR.Parser.Item.<b><font color='#F000F0'>error_lookahead</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Look-ahead set used for detecting conflicts</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>relation</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font>(<font color='#005080'>Item</font>) Parser.LR.Parser.Item.<b><font color='#F000F0'>relation</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Relation to other items (used when compiling).</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>counter</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>counter</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Depth counter (used when compiling).</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>number</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>number</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Item identification number (used when compiling).</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>item_id</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.Item.<b><font color='#F000F0'>item_id</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Used to identify the item.
 Equal to r-&gt;number + offset.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Parser.Kernel</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Implements an LR(1) state</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>rules</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font>(<font color='#005080'>Rule</font>) Parser.LR.Parser.Kernel.<b><font color='#F000F0'>rules</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Used to check if a rule already has been added when doing closures.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>items</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Item</font>) Parser.LR.Parser.Kernel.<b><font color='#F000F0'>items</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Contains the items in this state.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>item_id_to_item</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>int</font>:<font color='#005080'>Item</font>) Parser.LR.Parser.Kernel.<b><font color='#F000F0'>item_id_to_item</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Used to lookup items given rule and offset</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>symbol_items</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>int</font>:<font color='#202020'>multiset</font>(<font color='#005080'>Item</font>)) Parser.LR.Parser.Kernel.<b><font color='#F000F0'>symbol_items</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Contains the items whose next symbol is this non-terminal.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>action</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>int</font>|<font color='#202020'>string</font>:<font color='#005080'>Kernel</font>|<font color='#005080'>Rule</font>) Parser.LR.Parser.Kernel.<b><font color='#F000F0'>action</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The action table for this state</p>
<p><font face='courier'><pre>
 object(kernel)    SHIFT to this state on this symbol.
 object(rule)      REDUCE according to this rule on this symbol.
 </pre></font></p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>closure_set</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font> Parser.LR.Parser.Kernel.<b><font color='#F000F0'>closure_set</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The symbols that closure has been called on.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_item</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>add_item</font>(</b><font color='#005080'>Item</font> <font color='#005080'>i</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Add an item to the state.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>closure</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>closure</font>(</b><font color='#202020'>int</font> <font color='#005080'>nonterminal</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Make the closure of this state.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>nonterminal</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Nonterminal to make the closure on.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>goto_set</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>multiset</font>(<font color='#202020'>int</font>|<font color='#202020'>string</font>) <b><font color='#000066'>goto_set</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Make the goto-set of this state.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>do_goto</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Kernel</font> <b><font color='#000066'>do_goto</font>(</b><font color='#202020'>int</font>|<font color='#202020'>string</font> <font color='#005080'>symbol</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Generates the state reached when doing goto on the specified symbol.
 i.e. it compiles the LR(0) state.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>symbol</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Symbol to make goto on.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.LR.Parser.StateQueue</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This is a queue, which keeps the elements even after they are retrieved.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>head</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.StateQueue.<b><font color='#F000F0'>head</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Index of the head of the queue.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>tail</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.Parser.StateQueue.<b><font color='#F000F0'>tail</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Index of the tail of the queue.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>arr</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Kernel</font>) Parser.LR.Parser.StateQueue.<b><font color='#F000F0'>arr</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The queue itself.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>push</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Kernel</font> <b><font color='#000066'>push</font>(</b><font color='#005080'>Kernel</font> <font color='#005080'>state</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Pushes the state on the queue.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>state</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>State to push.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>next</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Kernel</font> <b><font color='#000066'>next</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return the next state from the queue.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.LR.GrammarParser</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This module generates an LR parser from a grammar specified according
 to the following grammar:</p>
<p><font face='courier'><pre>
        directives : directive ;
	   directives : directives directive ;
	   directive : declaration ;
	   directive : rule ;
	   declaration : "%token" terminals ";" ;
	   rule : nonterminal ":" symbols ";" ;
	   rule : nonterminal ":" symbols action ";" ;
	   symbols : symbol ;
	   symbols : symbols symbol ;
	   terminals : terminal ;
	   terminals : terminals terminal ;
	   symbol : nonterminal ;
	   symbol : "string" ;
	   action : "{" "identifier" "}" ;
	   nonterminal : "identifier" ;
	   terminal : "string";
 </pre></font></p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'></font><dt>
<dd><p></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>lr_error</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.LR.GrammarParser.<b><font color='#F000F0'>lr_error</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Error code from the parsing.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>make_parser</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Parser</font> <b><font color='#000066'>make_parser</font>(</b><font color='#202020'>string</font> <font color='#005080'>str</font>, <font color='#202020'>object</font>|<font color='#202020'>void</font> <font color='#005080'>m</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Compiles the parser-specification given in the first argument.
 Named actions are taken from the object if available, otherwise
 left as is.</p>
</font></dd>
<dt><font face='Helvetica'>Bugs</font><dt>
<dd><font face='Helvetica'><p>Returns error-code in both GrammarParser.error and
 return_value-&gt;lr_error.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>make_parser_from_file</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>|<font color='#005080'>Parser</font> <b><font color='#000066'>make_parser_from_file</font>(</b><font color='#202020'>string</font> <font color='#005080'>fname</font>, <font color='#202020'>object</font>|<font color='#202020'>void</font> <font color='#005080'>m</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Compiles the file specified in the first argument into an LR parser.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>make_parser</font> </p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML</b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>autoconvert</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>autoconvert</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font><b>)</b></tt></p></dd>
</dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Validating</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Validating XML parser.</p>
<p> Validates an XML file according to a DTD.</p>
<p> cf http://wwww.w3.org/TR/REC-xml/</p>
<p> $Id: Validating.pike,v 1.20 2008/12/01 10:03:42 grubba Exp $</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Simple</b></font>
</font><dt>
<dd><p><font face='courier'>inherit .Simple</font><font face='courier'> : <font color='#F000F0'>Simple</font></font></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Extends the Simple XML parser.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isname</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isname</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid <tt>Name</tt>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnmtoken</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnmtoken</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid <tt>Nmtoken</tt>.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnames</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnames</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid list of <tt>Name</tt>s.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>isnmtokens</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>isnmtokens</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check if <font face='courier'>s</font>  is a valid list of <tt>Nmtoken</tt>s.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_external_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_external_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>sysid</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>pubid</font>, <font color='#202020'>mapping</font>|<font color='#600000'>__deprecated__</font>(<font color='#202020'>int</font>)|<font color='#202020'>void</font> <font color='#005080'>info</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Get an external entity.</p>
<p> Called when a <tt>&lt;!DOCTYPE&gt;</tt> with a <tt>SYSTEM</tt> identifier
 is encountered, or when an entity reference needs expanding.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>sysid</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>SYSTEM</tt> identifier.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>pubid</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>PUBLIC</tt> identifier (if any).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>info</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The callbackinfo mapping containing the current parser state.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>extra</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The <tt>extra</tt> arguments as passed to <font face='courier'>parse()</font>  or <font face='courier'>parse_dtd()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns a string with a DTD fragment on success.
   Returns <font face='courier'><code>0</code></font> (zero) on failure.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Returning zero will cause the validator to report an error.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>In Pike 7.7 and earlier <font face='courier'>info</font>  had the value <font face='courier'><code>0</code></font> (zero).</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The default implementation always returns <font face='courier'><code>0</code></font> (zero).
   Override this function to provide other behaviour.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse()</font> , <font face='courier'>parse_dtd()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>validate</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>validate</font>(</b><font color='#202020'>string</font> <font color='#005080'>kind</font>, <font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mapping</font> <font color='#005080'>attributes</font>, <font color='#202020'>array</font>|<font color='#202020'>string</font> <font color='#005080'>contents</font>, <font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>info</font>, <font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>array</font>(<font color='#202020'>mixed</font>) <font color='#005080'>extra</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The validation callback function.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>::parse()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>string</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>
<dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Document this function</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>string</font>|<font color='#202020'>function</font>(<font color='#202020'>string</font>:<font color='#202020'>mixed</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra</font><b>)</b></tt></p></dd>
<dt><font face='Helvetica' color='red'>FIXME</font></dt>
<dd><font face='Heletica' color='red'><p>Document this function</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Validating.Element</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML Element node.</p>
</font></dd></dl></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Simple</font></b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt><br />
<tt><font color='#202020'>array</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>xml</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>dtd</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt><br />
<tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><font color='#202020'>string</font> <font color='#005080'>dtd</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>lookup_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>lookup_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the verbatim expansion of the entity.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Added in Pike 7.7.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>define_entity_raw</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>define_entity_raw</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>string</font> <font color='#005080'>raw</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Define an entity or an SMEG.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>entity</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Entity name, or SMEG name (if preceeded by a <font face='courier'><code>"%"</code></font>).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>raw</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Verbatim expansion of the entity.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>define_entity()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>define_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>define_entity</font>(</b><font color='#202020'>string</font> <font color='#005080'>entity</font>, <font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extras</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Define an entity or an SMEG.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>entity</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Entity name, or SMEG name (if preceeded by a <font face='courier'><code>"%"</code></font>).</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Expansion of the entity. Entity evaluation will be performed.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>define_entity_raw()</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>allow_rxml_entities</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>allow_rxml_entities</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>yes_no</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>compat_allow_errors</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>compat_allow_errors</font>(</b><font color='#202020'>string</font> <font color='#005080'>version</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Set whether the parser should allow certain errors for
 compatibility with earlier versions. <font face='courier'>version</font>  can be:</p>
<table bgcolor='black' border='0' cellspacing='0' cellpadding='0'><tr><td>
<table cellspacing='1' cellpadding='3' border='0' bgcolor='black'>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"7.2"</font></tt></td><td bgcolor='white'><p>Allow more data after the root element.</p>
</td></tr>
<tr valign='top'><td bgcolor='white'><tt><font color='green'>"7.6"</font></tt></td><td bgcolor='white'><p>Allow multiple and invalidly placed "&lt;?xml ... ?&gt;" and
     "&lt;!DOCTYPE ... &gt;" declarations (invalid "&lt;?xml ... ?&gt;"
     declarations are otherwise treated as normal PI:s). Allow
     "&lt;![CDATA[ ... ]]&gt;" outside the root element. Allow the root
     element to be absent.</p>
</td></tr>
</table></td></tr></table><br />
<p><font face='courier'>version</font>  can also be zero to enable all error checks.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Simple.Context</font></b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_xml</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_xml</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_dtd</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>parse_dtd</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_entity</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>parse_entity</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>push_string</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>push_string</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font><b>)</b></tt><br />
<tt><font color='#202020'>void</font> <b><font color='#000066'>push_string</font>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>string</font> <font color='#005080'>context</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Add a string to parse at the current position.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>String to insert at the current parsing position.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>context</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Optional context used to refer to the inserted string.
   This is typically an URL, but may also be an entity
   (preceeded by an <font face='courier'><code>"&amp;"</code></font>) or a SMEG reference
   (preceeded by a <font face='courier'><code>"%"</code></font>).
   Not used by the XML parser as such, but is simply
   passed into the callbackinfo mapping as
   the field <font face='courier'><code>"context"</code></font> where it can be useful
   for eg resolving relative URLs when parsing DTDs,
   or for determining where errors occur.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.XML.Simple.Context<b>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>string</font> <font color='#005080'>context</font>, <font color='#202020'>int</font> <font color='#005080'>flags</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt><br />
<tt><font color='#202020'>void</font> Parser.XML.Simple.Context<b>(</b><font color='#202020'>string</font> <font color='#005080'>s</font>, <font color='#202020'>int</font> <font color='#005080'>flags</font>, <font color='#202020'>function</font> <font color='#005080'>cb</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>extra_args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>s</font></tt></font><dt>
<dd></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>context</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>These two arguments are passed along to <font face='courier'>push_string()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>flags</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Parser flags.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>cb</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Callback function. This function gets called at various
   stages during the parsing.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The <font face='courier'>context</font>  argument was introduced in Pike 7.8.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.NSTree</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A namespace aware version of Parser.XML.Tree. This implementation
 does as little validation as possible, so e.g. you can call your
 namespace xmlfoo without complaints.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Tree</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Parser.XML.Tree</font><font face='courier'> : <font color='#F000F0'>Tree</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>NSNode</font> <b><font color='#000066'>parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>default_ns</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes a XML string <font face='courier'>data</font>  and produces a namespace node tree.
 If <font face='courier'>default_ns</font>  is given, it will be used as the default namespace.</p>
</font></dd>
<dt><font face='Helvetica'>Throws</font><dt>
<dd><font face='Helvetica'><p>Throws an <font face='courier'>error</font>  when an error is encountered during XML
   parsing.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>visualize</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>visualize</font>(</b><font color='#005080'>Node</font> <font color='#005080'>n</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>indent</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Makes a visualization of a node graph suitable for
 printing out on a terminal.</p>
</font></dd>
<dt><font face='Helvetica'>Example</font><dt>
<dd><pre><p>&gt; object x = parse_input("&lt;a&gt;&lt;b&gt;&lt;c/&gt;d&lt;/b&gt;&lt;b&gt;&lt;e/&gt;&lt;f&gt;g&lt;/f&gt;&lt;/b&gt;&lt;/a&gt;");
   &gt; write(visualize(x));
   Node(ROOT)
     NSNode(ELEMENT,"a")
       NSNode(ELEMENT,"b")
         NSNode(ELEMENT,"c")
         NSNode(TEXT)
       NSNode(ELEMENT,"b")
         NSNode(ELEMENT,"e")
         NSNode(ELEMENT,"f")
           NSNode(TEXT)
   Result 1: 201</p>
</pre></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.NSTree.NSNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Namespace aware node.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Node</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Node</font><font face='courier'> : <font color='#F000F0'>Node</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_ns</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the namespace in which the current element is defined in.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_default_ns</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_default_ns</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the default namespace in the current scope.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_defined_nss</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_defined_nss</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a mapping with all the namespaces defined in the current
 scope, except the default namespace.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned mapping is the same as the one in the node, so
   destructive changes will affect the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_ns_attributes</font>(</b><font color='#202020'>string</font> <font color='#005080'>namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the attributes in this node that is declared in the provided
 namespace.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ns_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)) <b><font color='#000066'>get_ns_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the attributes in all namespaces that is associated with
 this node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned mapping is the same as the one in the node, so
   destructive changes will affect the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_namespace</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>add_namespace</font>(</b><font color='#202020'>string</font> <font color='#005080'>ns</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>symbol</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>chain</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds a new namespace to this node. The preferred symbol to
 use to identify the namespace can be provided in the <font face='courier'>symbol</font> 
 argument. If <font face='courier'>chain</font>  is set, no attempts to overwrite an
 already defined namespace with the same identifier will be made.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>diff_namespaces</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>diff_namespaces</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the difference between this nodes and its parents namespaces.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_xml_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_xml_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the element name as it occurs in xml files. E.g.
 "zonk:name" for the element "name" defined in a namespace
 denoted with "zonk". It will look up a symbol for the namespace
 in the symbol tables for the node and its parents. If none is
 found a new label will be generated by hashing the namespace.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>NSNode</font> <font color='#005080'>child</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The remove_child is a not updated to take care of name
 space issues. To properly remove all the parents name spaces
 from the chid, call <font face='courier'>remove_node</font>  in the child.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.Tree</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML parser that generates node-trees.</p>
<p> Has some support for XML namespaces
 <a href='http://www.w3.org/TR/REC-xml-names/'>http://www.w3.org/TR/REC-xml-names/</a>
 RFC 2518 23.4.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>This module defines two sets of node trees;
   the <font face='courier'>SimpleNode</font> -based, and the <font face='courier'>Node</font> -based.
   The main difference between the two, is that
   the <font face='courier'>Node</font> -based trees have parent pointers,
   which tend to generate circular data references
   and thus garbage.</p>
<p>   There are some more subtle differences between
   the two. Please read the documentation carefully.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>STOP_WALK</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>STOP_WALK</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ROOT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ROOT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ELEMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ELEMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_TEXT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_TEXT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_HEADER</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_HEADER</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_PI</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_PI</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_COMMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_COMMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_DOCTYPE</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_DOCTYPE</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_ATTR</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_ATTR</font></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Attribute nodes are created on demand</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ENTITY</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ENTITY</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ELEMENT</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ELEMENT</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_ATTLIST</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_ATTLIST</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>DTD_NOTATION</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>DTD_NOTATION</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Constant</font>
<font size='+1'><b>XML_NODE</b></font>
</font><dt>
<dd><p><tt>constant Parser.XML.Tree.<font color='#F000F0'>XML_NODE</font></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>text_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>text_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes the string given in <font face='courier'>data</font>  by escaping &amp;, &lt; and &gt;.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>roxen_text_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>roxen_text_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes strings just like <font face='courier'>text_quote</font> , but entities in the form
 <tt>&amp;foo.bar;</tt> will not be quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>attribute_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>attribute_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes the string given in <font face='courier'>data</font>  by escaping &amp;, &lt;, &gt;, ' and ".</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>roxen_attribute_quote</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>roxen_attribute_quote</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Quotes strings just like <font face='courier'>attribute_quote</font> , but entities in the
 form <tt>&amp;foo.bar;</tt> will not be quoted.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleRootNode</font> <b><font color='#000066'>simple_parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>predefined_entities</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>default_namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes an XML string and produces a <font face='courier'>SimpleNode</font>  tree.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_parse_file</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleRootNode</font> <b><font color='#000066'>simple_parse_file</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>predefined_entities</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font>, <font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>default_namespace</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Loads the XML file <font face='courier'>path</font> , creates a <font face='courier'>SimpleNode</font>  tree representation and
 returns the root node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_input</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>RootNode</font> <b><font color='#000066'>parse_input</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>no_fallback</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>force_lowercase</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>predefined_entities</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>parse_namespaces</font>, <font color='#005080'>ParseFlags</font>|<font color='#202020'>void</font> <font color='#005080'>flags</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Takes an XML string and produces a node tree.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flags</font>  is not used for <font face='courier'>PARSE_WANT_ERROR_CONTEXT</font> ,
 <font face='courier'>PARSE_FORCE_LOWERCASE</font>  or <font face='courier'>PARSE_ENABLE_NAMESPACES</font>  since they
 are covered by the separate flag arguments.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse_file</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Node</font> <b><font color='#000066'>parse_file</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>parse_namespaces</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Loads the XML file <font face='courier'>path</font> , creates a node tree representation and
 returns the root node.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; ENUM <b><font color='#005080'>Parser.XML.Tree.ParseFlags</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Flags used together with <font face='courier'>simple_parse_input()</font>  and
 <font face='courier'>simple_parse_file()</font> .</p>
</font></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.XMLNSParser</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Namespace aware parser.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>Enter</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>Enter</font>(</b><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>attrs</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Check <font face='courier'>attrs</font>  for namespaces.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the namespace expanded version of <font face='courier'>attrs</font> .</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.AbstractSimpleNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Base class for nodes.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <b><font color='#000066'>get_children</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the nodes children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>count_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>count_children</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the number of children of the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>low_clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>low_clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns an initialized copy of the node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned node has no children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a clone of the sub-tree rooted in the node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_last_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>get_last_child</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the last child node or zero.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`[]</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>`[]</font>(</b><font color='#202020'>int</font> <font color='#005080'>pos</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The [] operator indexes among the node children, so
 <font face='courier'><code>node[0]</code></font> returns the first node and <font face='courier'><code>node[-1]</code></font> the last.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The [] operator will select a node from all the nodes children,
   not just its element children.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the given node to the list of children of this node. The
 new node is added last in the list.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The return value differs from the one returned
   by <font face='courier'>Node()-&gt;add_child()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_before</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_before</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added last if <font face='courier'>old</font>  is
 zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_after</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_after</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all occurrences of the provided node from the list of
 children of this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>replace_children</font>(</b><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <font color='#005080'>children</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the nodes children with the provided ones.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>replace_child</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the first occurrence of the old node child with
 the new node child.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The return value differs from the one returned
   by <font face='courier'>Node()-&gt;replace_child()</font> .</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the current node on success, and <font face='courier'><code>0</code></font> (zero)
   if the node <font face='courier'>old</font>  wasn't found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>zap_tree</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>zap_tree</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Destruct the tree recursively. When the inheriting
 <font face='courier'>AbstractNode</font>  or <font face='courier'>Node</font>  is used, which have parent pointers,
 this function should be called for every tree that no longer is
 in use to avoid frequent garbage collector runs.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_preorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_preorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in preorder, root node first, then
 subtrees from left to right, calling the callback function
 for every node. If the callback function returns <font face='courier'>STOP_WALK</font> 
 the traverse is promptly aborted and <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_preorder_2</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_preorder_2</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>cb_1</font>, <font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>cb_2</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in preorder, root node first, then
 subtrees from left to right. For each node we call <font face='courier'>cb_1</font> 
 before iterating through children, and then <font face='courier'>cb_2</font> 
 (which always gets called even if the walk is aborted earlier).
 If the callback function returns <font face='courier'>STOP_WALK</font>  the traverse
 decend is aborted and <font face='courier'>STOP_WALK</font>  is returned once all waiting
 <font face='courier'>cb_2</font>  functions have been called.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_inorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_inorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in inorder, left subtree first, then
 root node, and finally the remaining subtrees, calling the function
 <font face='courier'>callback</font>  for every node. If the function <font face='courier'>callback</font>  returns
 <font face='courier'>STOP_WALK</font>  the traverse is promptly aborted and <font face='courier'>STOP_WALK</font> 
 is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>walk_postorder</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>walk_postorder</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Traverse the node subtree in postorder, first subtrees from left
 to right, then the root node, calling the function <font face='courier'>callback</font> 
 for every node. If the function <font face='courier'>callback</font>  returns <font face='courier'>STOP_WALK</font> 
 the traverse is promptly aborted and <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>iterate_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>iterate_children</font>(</b><font color='#202020'>function</font>(<font color='#005080'>AbstractSimpleNode</font>:<font color='#202020'>int</font>|<font color='#202020'>void</font>) <font color='#005080'>callback</font>, <font color='#202020'>mixed</font> ...  <font color='#005080'>args</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Iterates over the nodes children from left to right, calling the
 function <font face='courier'>callback</font>  for every node. If the callback function
 returns <font face='courier'>STOP_WALK</font>  the iteration is promptly aborted and
 <font face='courier'>STOP_WALK</font>  is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendants</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractSimpleNode</font>) <b><font color='#000066'>get_descendants</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>include_self</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a list of all descendants in document order. Includes
 this node if <font face='courier'>include_self</font>  is set.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.AbstractNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Base class for nodes with parent pointers.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractSimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractSimpleNode</font><font face='courier'> : <font color='#F000F0'>AbstractSimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_parent</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_parent</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>parent</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Sets the parent node to <font face='courier'>parent</font> .</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_parent</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_parent</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the parent node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>low_clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>low_clone</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns an initialized copy of the node.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned node has no children, and no parent.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>clone</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>clone</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font>(-1..1) <font color='#005080'>direction</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clones the node, optionally connected to parts of the tree.
 If direction is -1 the cloned nodes parent will be set, if
 direction is 1 the clone nodes childen will be set.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_root</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_root</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Follows all parent pointers and returns the root node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>add_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Returns the new child node, NOT the current node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The new child node is returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_before</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_before</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added last if <font face='courier'>old</font>  is
 zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>add_child_after</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractSimpleNode</font> <b><font color='#000066'>add_child_after</font>(</b><font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractSimpleNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Adds the node <font face='courier'>c</font>  to the list of children of this node. The
 node is added before the node <font face='courier'>old</font> , which is assumed to be an
 existing child of this node. The node is added first if <font face='courier'>old</font> 
 is zero.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>The current node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child_before</b></font><br />
<font face='Helvetica'>Method</font>
<font size='+1'><b>tmp_add_child_after</b></font><br />
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt><br />
<tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child_before</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>old</font><b>)</b></tt><br />
<tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>tmp_add_child_after</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>old</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Variants of <font face='courier'>add_child</font> , <font face='courier'>add_child_before</font>  and
 <font face='courier'>add_child_after</font>  that doesn't set the parent pointer in the
 newly added children.</p>
<p> This is useful while building a node tree, to get efficient
 refcount garbage collection if the build stops abruptly.
 <font face='courier'>fix_tree</font>  has to be called on the root node when the building
 is done.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>fix_tree</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>fix_tree</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Fix all parent pointers recursively in a tree that has been
 built with <font face='courier'>tmp_add_child</font> .</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_child</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>c</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes all occurrences of the provided node from the called nodes
 list of children. The removed nodes parent reference is set to null.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>remove_node</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>remove_node</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Removes this node from its parent. The parent reference is set to null.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_children</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>replace_children</font>(</b><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <font color='#005080'>children</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the nodes children with the provided ones. All parent
 references are updated.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_child</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>replace_child</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>old</font>, <font color='#005080'>AbstractNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces the first occurrence of the old node child with
 the new node child. All parent references are updated.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The returned value is NOT the current node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new child node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>replace_node</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>replace_node</font>(</b><font color='#005080'>AbstractNode</font> <font color='#005080'>new</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Replaces this node with the provided one.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the new node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_preceding_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_preceding_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all preceding siblings, i.e. all siblings present before
 this node in the parents children list.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_following_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_following_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all following siblings, i.e. all siblings present after
 this node in the parents children list.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_siblings</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_siblings</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all siblings, including this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_ancestors</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_ancestors</font>(</b><font color='#202020'>int</font>(0..1) <font color='#005080'>include_self</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns a list of all ancestors, with the top node last.
 The list will start with this node if <font face='courier'>include_self</font>  is set.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_preceding</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_preceding</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all preceding nodes, excluding this nodes ancestors.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_following</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_following</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all the nodes that follows after the current one.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.VirtualNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Node in XML tree</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <b><font color='#000066'>get_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns this nodes attributes, which can be altered
 destructivly to alter the nodes attributes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_short_attributes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font> <b><font color='#000066'>get_short_attributes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns this nodes name-space adjusted attributes.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>set_short_namespaces()</font>  must have been called before
   calling this function.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_node_type</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_node_type</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the node type. See defined node type constants.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_text</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_text</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns text content in node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_doc_order</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_doc_order</font>(</b><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_doc_order</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_doc_order</font>(</b><font color='#202020'>int</font> <font color='#005080'>o</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the element node, or the nearest element above if
 an attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_any_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_any_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return name of tag or name of attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>set_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>set_tag_name</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Change the tag name destructively. Can only be used on element and
 processing-instruction nodes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_namespace</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_namespace</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return the (resolved) namespace for this node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_full_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_full_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Return fully qualified name of the element node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.XML.Tree.VirtualNode<b>(</b><font color='#202020'>int</font> <font color='#005080'>type</font>, <font color='#202020'>string</font> <font color='#005080'>name</font>, <font color='#202020'>mapping</font> <font color='#005080'>attr</font>, <font color='#202020'>string</font> <font color='#005080'>text</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>value_of_node</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>value_of_node</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If the node is an attribute node or a text node, its value is returned.
 Otherwise the child text nodes are concatenated and returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_first_element</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>AbstractNode</font> <b><font color='#000066'>get_first_element</font>(</b><font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>name</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>full</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the first element child to this node.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>name</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If provided, the first element child with that name is returned.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>full</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If specified, name matching will be done against the full name.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the first matching node, and 0 if no such node was found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>AbstractNode</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font>|<font color='#202020'>void</font> <font color='#005080'>name</font>, <font color='#202020'>int</font>(0..1)|<font color='#202020'>void</font> <font color='#005080'>full</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all element children to this node.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>name</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If provided, only elements with that name is returned.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>full</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>If specified, name matching will be done against the full name.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns an array with matching nodes.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>cast</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>cast</font>(</b><font color='#202020'>string</font> <font color='#005080'>to</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>It is possible to cast a node to a string, which will return
 <font face='courier'>render_xml()</font>  for that node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>render_xml</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>render_xml</font>(</b><font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>preserve_roxen_entities</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>namespace_lookup</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates an XML representation of the node sub tree. If the
 flag <font face='courier'>preserve_roxen_entities</font>  is set, entities on the form
 <tt>&amp;foo.bar;</tt> will not be escaped.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>namespace_lookup</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Mapping from namespace prefix to namespace symbol prefix.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>render_to_file</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>render_to_file</font>(</b><font color='#005080'>Stdio.File</font> <font color='#005080'>f</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font>(0..1) <font color='#005080'>preserve_roxen_entities</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates an XML representation fo the node sub tree and streams
 the output to the file <font face='courier'>f</font> . If the flag <font face='courier'>preserve_roxen_entities</font> 
 is set, entities on the form <tt>&amp;foo.bar;</tt> will not be escaped.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.SimpleNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML node without parent pointers and attribute nodes.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractSimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractSimpleNode</font><font face='courier'> : <font color='#F000F0'>AbstractSimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>VirtualNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit VirtualNode</font><font face='courier'> : <font color='#F000F0'>VirtualNode</font></font></p></dd>
</dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.Node</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>XML node with parent pointers.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>AbstractNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit AbstractNode</font><font face='courier'> : <font color='#F000F0'>AbstractNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>VirtualNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit VirtualNode</font><font face='courier'> : <font color='#F000F0'>VirtualNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_tag_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_tag_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the element node, or the nearest element above if
 an attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attr_name</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_attr_name</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the name of the attribute node.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_attribute_nodes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Node</font>) <b><font color='#000066'>get_attribute_nodes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Creates and returns an array of new nodes; they will not be
 added as proper children to the parent node, but the parent
 link in the nodes are set so that upwards traversal is made
 possible.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.XMLParser</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Mixin for parsing XML.</p>
</font></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.SimpleRootNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The root node of an XML-tree consisting of <font face='courier'>SimpleNode</font> s.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>SimpleNode</b></font>
</font><dt>
<dd><p><font face='courier'>inherit SimpleNode</font><font face='courier'> : <font color='#F000F0'>SimpleNode</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>XMLParser</b></font>
</font><dt>
<dd><p><font face='courier'>inherit XMLParser</font><font face='courier'> : <font color='#F000F0'>XMLParser</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_element_by_id</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>SimpleElementNode</font> <b><font color='#000066'>get_element_by_id</font>(</b><font color='#202020'>string</font> <font color='#005080'>id</font>, <font color='#202020'>int</font>|<font color='#202020'>void</font> <font color='#005080'>force</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Find the element with the specified id.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>id</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The XML id of the node to search for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>force</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Force a regeneration of the id lookup cache.
   Needed the first time after the node tree has been
   modified by adding or removing element nodes, or
   by changing the id attribute of an element node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the element node with the specified id
   if any. Returns <font face='courier'>UNDEFINED</font>  otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flush_node_id_cache</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>flush_node_id_cache</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>flush_node_id_cache</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clears the node id cache built and used by <font face='courier'>get_element_by_id</font> .</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.Tree.RootNode</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The root node of an XML-tree consisting of <font face='courier'>Node</font> s.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Node</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Node</font><font face='courier'> : <font color='#F000F0'>Node</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>XMLParser</b></font>
</font><dt>
<dd><p><font face='courier'>inherit XMLParser</font><font face='courier'> : <font color='#F000F0'>XMLParser</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_element_by_id</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>ElementNode</font> <b><font color='#000066'>get_element_by_id</font>(</b><font color='#202020'>string</font> <font color='#005080'>id</font>, <font color='#202020'>int</font>|<font color='#202020'>void</font> <font color='#005080'>force</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Find the element with the specified id.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>id</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The XML id of the node to search for.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>force</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Force a regeneration of the id lookup cache.
   Needed the first time after the node tree has been
   modified by adding or removing element nodes, or
   by changing the id attribute of an element node.</p>
</font></dd>
<dt><font face='Helvetica'>Returns</font><dt>
<dd><font face='Helvetica'><p>Returns the element node with the specified id
   if any. Returns <font face='courier'>UNDEFINED</font>  otherwise.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>flush_node_id_cache</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>flush_node_id_cache</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> <b><font color='#000066'>flush_node_id_cache</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Clears the node id cache built and used by <font face='courier'>get_element_by_id</font> .</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.XML.SloppyDOM</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A somewhat DOM-like library that implements lazy generation of the
 node tree, i.e. it's generated from the data upon lookup. There's
 also a little bit of XPath evaluation to do queries on the node
 tree.</p>
<p> Implementation note: This is generally more pragmatic than
 <font face='courier'>Parser.XML.DOM</font> , meaning it's not so pretty and compliant, but
 more efficient.</p>
<p> Implementation status: There's only enough implemented to parse a
 node tree from source and access it, i.e. modification functions
 aren't implemented. Data hiding stuff like NodeList and
 NamedNodeMap is not implemented, partly since it's cumbersome to
 meet the "live" requirement. Also, <font face='courier'>Parser.HTML</font>  is used in XML
 mode to parse the input. Thus it's too error tolerant to be XML
 compliant, and it currently doesn't handle DTD elements, like
 <tt>"&lt;!DOCTYPE"</tt>, or the XML declaration (i.e. <tt>"&lt;?xml
 version='1.0'?&gt;"</tt>.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>parse</b></font>
</font><dt>
<dd><p><tt><font color='#005080'>Document</font> <b><font color='#000066'>parse</font>(</b><font color='#202020'>string</font> <font color='#005080'>source</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>raw_values</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Normally entities are decoded, and <font face='courier'>Node.xml_format</font>  will encode
 them again. If <font face='courier'>raw_values</font>  is nonzero then all text and attribute
 values are instead kept in their original form.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.Node</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Basic node.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_text_content</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>get_text_content</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If the <tt>raw_values</tt> flag is set in the owning document, the
 text is returned with entities and CDATA blocks intact.</p>
</font></dd>
<dt><font face='Helvetica'>See also</font><dt>
<dd><font face='Helvetica'><p><font face='courier'>parse</font> </p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_path</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)|<font color='#005080'>Node</font>|<font color='#202020'>array</font>(<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>)|<font color='#005080'>Node</font>)|<font color='#202020'>string</font> <b><font color='#000066'>simple_path</font>(</b><font color='#202020'>string</font> <font color='#005080'>path</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>xml_format</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Access a node or a set of nodes through an expression that is a
 subset of an XPath RelativeLocationPath in abbreviated form.</p>
<p> That means one or more Steps separated by "/" or "//". A Step
 consists of an AxisSpecifier followed by a NodeTest and then
 optionally by one or more Predicate's.</p>
<p> "/" before a Step causes it to be matched only against the
 immediate children of the node(s) selected by the previous Step.
 "//" before a Step causes it to be matched against any children
 in the tree below the node(s) selected by the previous Step.
 The initial selection before the first Step is this element.</p>
<p> The currently allowed AxisSpecifier NodeTest combinations are:</p>
<ul>
<li><p><tt>name</tt> to select all elements with the given name. The
   name can be <tt>"*"</tt> to select all.</p>
</li><li><p><tt>@name</tt> to select all attributes with the given name. The
   name can be <tt>"*"</tt> to select all.</p>
</li><li><p><tt>comment()</tt> to select all comments.</p>
</li><li><p><tt>text()</tt> to select all text and CDATA blocks. Note that
   all entity references are also selected, under the assumption
   that they would expand to text only.</p>
</li><li><p><tt>processing-instruction("name")</tt> to select all processing
   instructions with the given name. The name can be left out to
   select all. Either <tt>'</tt> or <tt>"</tt> may be used to delimit
   the name. For compatibility, it can also occur without
   surrounding quotes.</p>
</li><li><p><tt>node()</tt> to select all nodes, i.e. the whole content of an
   element node.</p>
</li><li><p><tt>.</tt> to select the currently selected element itself.</p>
</li></ul><p>A Predicate is on the form <tt>[PredicateExpr]</tt> where
 PredicateExpr currently can be in any of the following forms:</p>
<ul>
<li><p>An integer indexes one item in the selected set, according to
   the document order. A negative index counts from the end of
   the set.</p>
</li><li><p>A RelativeLocationPath as specified above. It's executed for
   each element in the selected set and those where it yields an
   empty result are filtered out while the rest remain in the
   set.</p>
</li><li><p>A RelativeLocationPath as specified above followed by
   <tt>="value"</tt>. The path is executed for each element in the
   selected set and those where the text result of it is equal to
   the given value remain in the set. Either <tt>'</tt> or <tt>"</tt>
   may be used to delimit the value.</p>
</li></ul><p>If <font face='courier'>xml_format</font>  is nonzero, the return value is an xml
 formatted string of all the matched nodes, in document order.
 Otherwise the return value is as follows:</p>
<p> Attributes are returned as one or more index/value pairs in a
 mapping. Other nodes are returned as the node objects. If the
 expression is on a form that can give at most one answer (i.e.
 there's a predicate with an integer index) then a single mapping
 or node is returned, or zero if there was no match. If the
 expression can give more answers then the return value is an
 array containing zero or more attribute mappings and/or nodes.
 The array follows document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>xml_format</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>xml_format</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the formatted XML that corresponds to the node tree.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.NodeWithChildElements</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Node with child elements.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>NodeWithChildren</b></font>
</font><dt>
<dd><p><font face='courier'>inherit NodeWithChildren</font><font face='courier'> : <font color='#F000F0'>NodeWithChildren</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Lightweight variant of <font face='courier'>get_elements_by_tag_name</font>  that returns
 a simple array instead of a fancy live NodeList.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendant_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_descendant_elements</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all descendant elements in document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_descendant_nodes</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Node</font>) <b><font color='#000066'>get_descendant_nodes</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns all descendant nodes (except attribute nodes) in
 document order.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.XML.SloppyDOM.Document</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>The node tree is very likely a cyclic structure, so it might be an
 good idea to destruct it when you're finished with it, to avoid
 garbage. Destructing the <font face='courier'>Document</font>  object always destroys all
 nodes in it.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>NodeWithChildElements</b></font>
</font><dt>
<dd><p><font face='courier'>inherit NodeWithChildElements</font><font face='courier'> : <font color='#F000F0'>NodeWithChildElements</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_elements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Element</font>) <b><font color='#000066'>get_elements</font>(</b><font color='#202020'>string</font> <font color='#005080'>name</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Note that this one looks among the top level elements, as
 opposed to <font face='courier'>get_elements_by_tag_name</font> . This means that if the
 document is correct, you can only look up the single top level
 element here.</p>
</font></dd>
<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>get_raw_values</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>get_raw_values</font>(</b><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Note</font><dt>
<dd><font face='Helvetica'><p>Not DOM compliant.</p>
</font></dd></dl>
</dd></dl></dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.Pike</b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>This module parses and tokenizes Pike source code.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>"C.pmod"</b></font><br />
</font><dt>
<dd><p><font face='courier'>inherit &quot;C.pmod&quot;</font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>split</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>) <b><font color='#000066'>split</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>state</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Splits the <font face='courier'>data</font>  string into an array of tokens. An additional
 element with a newline will be added to the resulting array of
 tokens. If the optional argument <font face='courier'>state</font>  is provided the split
 function is able to pause and resume splitting inside #"" and
 /**/ tokens. The <font face='courier'>state</font>  argument should be an initially empty
 mapping, in which split will store its state between successive
 calls.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.Pike.UnterminatedStringError</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Error thrown when an unterminated string token is encountered.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Inherit</font>
<font size='+1'><b>Generic</b></font>
</font><dt>
<dd><p><font face='courier'>inherit Error.Generic</font><font face='courier'> : <font color='#F000F0'>Generic</font></font></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>err_str</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.Pike.UnterminatedStringError.<b><font color='#F000F0'>err_str</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The string that failed to be tokenized</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.C</b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>split</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>) <b><font color='#000066'>split</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font> <font color='#005080'>state</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Splits the <font face='courier'>data</font>  string into an array of tokens. An additional
 element with a newline will be added to the resulting array of
 tokens. If the optional argument <font face='courier'>state</font>  is provided the split
 function is able to pause and resume splitting inside /**/ tokens.
 The <font face='courier'>state</font>  argument should be an initially empty mapping, in
 which split will store its state between successive calls.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>tokenize</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Token</font>) <b><font color='#000066'>tokenize</font>(</b><font color='#202020'>array</font>(<font color='#202020'>string</font>) <font color='#005080'>s</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>file</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns an array of <font face='courier'>Token</font>  objects given an array of string tokens.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>group</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Token</font>|<font color='#202020'>array</font>) <b><font color='#000066'>group</font>(</b><font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#005080'>Token</font>) <font color='#005080'>tokens</font>, <font color='#202020'>void</font>|<font color='#202020'>mapping</font>(<font color='#202020'>string</font>:<font color='#202020'>string</font>) <font color='#005080'>groupings</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Fold sub blocks of an array of tokens into sub arrays,
 for grouping purposes.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>tokens</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>The token array to fold.</p>
</font></dd>
<dt><font face='Helvetica'>Parameter <tt><font color='#8000F0'>groupings</font></tt></font><dt>
<dd></dd><dd><font face='Helvetica'><p>Supplies the tokens marking the boundaries of blocks to fold.
   The indices of the mapping mark the start of a block, the
   corresponding values mark where the block ends. The sub arrays
   will start and end in these tokens. If no groupings mapping is
   provided, {}, () and [] are used as block boundaries.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>strip_line_statements</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#005080'>Token</font>|<font color='#202020'>array</font>) <b><font color='#000066'>strip_line_statements</font>(</b><font color='#202020'>array</font>(<font color='#005080'>Token</font>|<font color='#202020'>array</font>) <font color='#005080'>tokens</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Strips off all (preprocessor) line statements from a token array.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>hide_whitespaces</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font> <b><font color='#000066'>hide_whitespaces</font>(</b><font color='#202020'>array</font> <font color='#005080'>tokens</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Folds all whitespace tokens into the previous token's trailing_whitespaces.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>simple_reconstitute</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>simple_reconstitute</font>(</b><font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#005080'>Token</font>|<font color='#202020'>array</font>) <font color='#005080'>tokens</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Reconstitutes the token array into a plain string again; essentially
 reversing <font face='courier'>split()</font>  and whichever of the <font face='courier'>tokenize</font> , <font face='courier'>group</font>  and
 <font face='courier'>hide_whitespaces</font>  methods may have been invoked.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>reconstitute_with_line_numbers</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>reconstitute_with_line_numbers</font>(</b><font color='#202020'>array</font>(<font color='#202020'>string</font>|<font color='#005080'>Token</font>|<font color='#202020'>array</font>) <font color='#005080'>tokens</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Like <font face='courier'>simple_reconstitute</font> , but adding additional <tt>#line n "file"</tt>
 preprocessor statements in the output whereever a new line or
 file starts.</p>
</font></dd></dl>
<dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; CLASS <b><font color='#005080'>Parser.C.Token</font></b></font></td></tr></table><br />
</dt><dd><dl>
<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Represents a C token, along with a selection of associated data and
 operations.</p>
</font></dd></dl>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>line</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> Parser.C.Token.<b><font color='#F000F0'>line</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The line where the token was found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>text</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.C.Token.<b><font color='#F000F0'>text</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The actual token.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>file</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.C.Token.<b><font color='#F000F0'>file</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>The file in which the token was found.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Variable</font>
<font size='+1'><b>trailing_whitespaces</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> Parser.C.Token.<b><font color='#F000F0'>trailing_whitespaces</font></b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Trailing whitespaces.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>create</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>void</font> Parser.C.Token<b>(</b><font color='#202020'>string</font> <font color='#005080'>text</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>line</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>file</font>, <font color='#202020'>void</font>|<font color='#202020'>string</font> <font color='#005080'>trailing_whitespace</font><b>)</b></tt></p></dd>
</dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>_sprintf</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>_sprintf</font>(</b><font color='#202020'>int</font> <font color='#005080'>how</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>If the object is printed as %s it will only output its text contents.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`==</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font> <b><font color='#000066'>`==</font>(</b><font color='#202020'>mixed</font> <font color='#005080'>foo</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Tokens are considered equal if the text contents are equal. It
 is also possible to compare the Token object with a text string
 directly.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`+</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>`+</font>(</b><font color='#202020'>string</font> ...  <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A string can be added to the Token, which will be added to the
 text contents.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>``+</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>string</font> <b><font color='#000066'>``+</font>(</b><font color='#202020'>string</font> ...  <font color='#005080'>s</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>A string can be added to the Token, which will be added to the
 text contents.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>cast</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>mixed</font> <b><font color='#000066'>cast</font>(</b><font color='#202020'>string</font> <font color='#005080'>to</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>It is possible to case a Token object to a string. The text content
 will be returned.</p>
</font></dd></dl>


<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>`[]</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>int</font>|<font color='#202020'>string</font> <b><font color='#000066'>`[]</font>(</b><font color='#202020'>int</font> <font color='#005080'>a</font>, <font color='#202020'>void</font>|<font color='#202020'>int</font> <font color='#005080'>b</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Characters and ranges may be indexed from the text contents of the token.</p>
</font></dd></dl>
</dd></dl></dd></dl><dl><dt><table width='100%' cellpadding='3' cellspacing='0' border='0'><tr><td bgcolor='#EEEEEE'><font size='+3'>&nbsp; Module <b>Parser.Python</b></font></td></tr></table><br />
</dt><dd>

<hr clear='all' size='1' noshadow='noshadow' />
<dl>
<dt><font face='Helvetica'><font face='Helvetica'>Method</font>
<font size='+1'><b>split</b></font>
</font><dt>
<dd><p><tt><font color='#202020'>array</font>(<font color='#202020'>string</font>) <b><font color='#000066'>split</font>(</b><font color='#202020'>string</font> <font color='#005080'>data</font><b>)</b></tt></p></dd>

<dt><font face='Helvetica'>Description</font><dt>
<dd><font face='Helvetica'><p>Returns the provided string with Python code as
 an array with tokens.</p>
</font></dd></dl>
</dd></dl></dd></dl></dd></dl></body></html>